#define MAX_SURFACES 24

void load_lens_data(
    int lens_type,
    output float radii[MAX_SURFACES],
    output float thicknesses[MAX_SURFACES],
    output float iors[MAX_SURFACES],
    output float apertures[MAX_SURFACES],
    output float abbe_v[MAX_SURFACES],
    output int num_surfaces,
    output int stop_index)
{
    if (lens_type == 0) {
        // Double Gauss 50mm f/2 (PBRT, US Patent 2,673,491)
        // Listed front-to-back (scene-side to sensor-side)
        num_surfaces = 11;
        stop_index = 5;
        radii[0]  =  29.475;  thicknesses[0]  = 3.76;  iors[0]  = 1.67;  apertures[0]  = 25.2;  abbe_v[0]  = 57.0;
        radii[1]  =  84.83;   thicknesses[1]  = 0.12;  iors[1]  = 1.0;   apertures[1]  = 25.2;  abbe_v[1]  = 0.0;
        radii[2]  =  19.275;  thicknesses[2]  = 4.025; iors[2]  = 1.67;  apertures[2]  = 23.0;  abbe_v[2]  = 57.0;
        radii[3]  =  40.77;   thicknesses[3]  = 3.275; iors[3]  = 1.699; apertures[3]  = 23.0;  abbe_v[3]  = 30.0;
        radii[4]  =  12.75;   thicknesses[4]  = 5.705; iors[4]  = 1.0;   apertures[4]  = 18.0;  abbe_v[4]  = 0.0;
        radii[5]  =   0.0;    thicknesses[5]  = 4.5;   iors[5]  = 1.0;   apertures[5]  = 17.1;  abbe_v[5]  = 0.0;
        radii[6]  = -14.495;  thicknesses[6]  = 1.18;  iors[6]  = 1.603; apertures[6]  = 17.0;  abbe_v[6]  = 38.0;
        radii[7]  =  40.77;   thicknesses[7]  = 6.065; iors[7]  = 1.658; apertures[7]  = 20.0;  abbe_v[7]  = 50.0;
        radii[8]  = -20.385;  thicknesses[8]  = 0.19;  iors[8]  = 1.0;   apertures[8]  = 20.0;  abbe_v[8]  = 0.0;
        radii[9]  = 437.065;  thicknesses[9]  = 3.22;  iors[9]  = 1.717; apertures[9]  = 20.0;  abbe_v[9]  = 48.0;
        radii[10] = -39.73;   thicknesses[10] = 0.0;   iors[10] = 1.0;   apertures[10] = 20.0;  abbe_v[10] = 0.0;
    }
}

int intersect_sphere(
    point ray_origin,
    vector ray_dir,
    float sphere_center_z,
    float radius,
    output point hit_point)
{
    float ox = ray_origin[0];
    float oy = ray_origin[1];
    float oz = ray_origin[2] - sphere_center_z;
    float dx = ray_dir[0];
    float dy = ray_dir[1];
    float dz = ray_dir[2];

    float a = dx * dx + dy * dy + dz * dz;
    float b = 2.0 * (ox * dx + oy * dy + oz * dz);
    float c = ox * ox + oy * oy + oz * oz - radius * radius;

    float disc = b * b - 4.0 * a * c;
    if (disc < 0.0)
        return 0;

    float sqrt_disc = sqrt(disc);
    float t1 = (-b - sqrt_disc) / (2.0 * a);
    float t2 = (-b + sqrt_disc) / (2.0 * a);

    // Pick the intersection closest to the vertex (sphere_center_z - radius).
    // Do NOT fall back to the far-side intersection — if the vertex-side hit
    // is behind the ray, the ray has passed this surface and should be rejected.
    float vertex_z = sphere_center_z - radius;
    point p1 = ray_origin + t1 * ray_dir;
    point p2 = ray_origin + t2 * ray_dir;

    float dist1 = abs(p1[2] - vertex_z);
    float dist2 = abs(p2[2] - vertex_z);

    if (dist1 < dist2) {
        if (t1 > 1e-6) {
            hit_point = p1;
            return 1;
        }
    } else {
        if (t2 > 1e-6) {
            hit_point = p2;
            return 1;
        }
    }

    return 0;
}

// Returns: 1 = success, 0 = intersection miss, -1 = aperture clip, -2 = TIR
int refract_at_surface(
    point ray_origin,
    vector ray_dir,
    float vertex_z,
    float radius,
    float semi_aperture,
    float n1,
    float n2,
    output point new_origin,
    output vector new_dir)
{
    // Aperture stop: flat plane intersection, no refraction
    if (radius == 0.0) {
        float dz = ray_dir[2];
        if (abs(dz) < 1e-10)
            return 0;
        float t = (vertex_z - ray_origin[2]) / dz;
        if (t < 1e-6)
            return 0;
        new_origin = ray_origin + t * ray_dir;
        float r = sqrt(new_origin[0] * new_origin[0] + new_origin[1] * new_origin[1]);
        if (r > semi_aperture)
            return -1;
        new_dir = ray_dir;
        return 1;
    }

    float sphere_center_z = vertex_z + radius;
    point hit = point(0, 0, 0);

    if (!intersect_sphere(ray_origin, ray_dir, sphere_center_z, radius, hit))
        return 0;

    // Aperture clip
    float r = sqrt(hit[0] * hit[0] + hit[1] * hit[1]);
    if (r > semi_aperture)
        return -1;

    // Surface normal: points from sphere center to hit point
    vector N = normalize(hit - point(0, 0, sphere_center_z));

    // Flip normal to face the incoming ray
    vector I = normalize(ray_dir);
    if (dot(I, N) > 0.0)
        N = -N;

    float eta = n1 / n2;
    vector refracted = refract(I, N, eta);

    // TIR check: refract() returns zero vector on total internal reflection
    if (dot(refracted, refracted) < 1e-10)
        return -2;

    new_origin = hit;
    new_dir = refracted;
    return 1;
}

// failure_type output: 0 = success, 1 = intersection miss, 2 = aperture clip, 3 = TIR
int trace_lens_system(
    point ray_origin,
    vector ray_dir,
    float aperture_scale,
    int num_surfaces,
    int stop_index,
    float radii[MAX_SURFACES],
    float thicknesses[MAX_SURFACES],
    float iors[MAX_SURFACES],
    float apertures[MAX_SURFACES],
    output point exit_origin,
    output vector exit_dir,
    output int surfaces_passed,
    output int failure_type)
{
    surfaces_passed = 0;
    failure_type = 0;

    // Compute vertex z-positions (PBRT convention: front at most negative z,
    // rear at z=0). This ensures sphere curvature pushes off-axis hits away
    // from subsequent surfaces, preventing overshoot at thin air gaps.
    float vertex_z[MAX_SURFACES];
    float total_length = 0.0;
    for (int i = 0; i < num_surfaces - 1; i++)
        total_length += thicknesses[i];

    vertex_z[0] = -total_length;
    for (int i = 1; i < num_surfaces; i++)
        vertex_z[i] = vertex_z[i - 1] + thicknesses[i - 1];

    point  p = ray_origin;
    vector d = ray_dir;

    // Trace rear-to-front: last surface down to surface 0
    for (int idx = num_surfaces - 1; idx >= 0; idx--) {
        float semi_ap = apertures[idx] * 0.5;

        if (idx == stop_index)
            semi_ap *= aperture_scale;

        // iors[i] = IOR of the medium between surface i and surface i+1
        // (toward sensor). When tracing sensor→scene at surface idx:
        // n1 = medium the ray is in (sensor side) = iors[idx]
        // n2 = medium the ray enters (scene side) = iors[idx-1] or air
        float n1 = iors[idx];
        float n2 = (idx > 0) ? iors[idx - 1] : 1.0;

        // No refraction at aperture stop
        if (radii[idx] == 0.0) {
            n1 = 1.0;
            n2 = 1.0;
        }

        point  new_p = point(0, 0, 0);
        vector new_d = vector(0, 0, 0);

        int result = refract_at_surface(p, d, vertex_z[idx], radii[idx], semi_ap, n1, n2, new_p, new_d);
        if (result != 1) {
            if (result == 0) failure_type = 1;
            else if (result == -1) failure_type = 2;
            else if (result == -2) failure_type = 3;
            return 0;
        }

        surfaces_passed += 1;
        p = new_p;
        d = new_d;
    }

    exit_origin = p;
    exit_dir = d;
    return 1;
}

shader lens_camera(
    float sensor_distance = 55.0
        [[ string description = "Distance from sensor to rear lens vertex (mm). Controls focus." ]],
    float aperture_scale = 1.0
        [[ string description = "Scale factor for the aperture stop opening. 1.0 = wide open (f/2)." ]],
    int lens_type = 0
        [[ string description = "Lens selection. 0 = Double Gauss 50mm f/2." ]],
    float debug_mode = 0.0
        [[ string description = "0=normal, 1=pinhole, 2=surface count, 3=exit direction" ]],
    output point position = 0,
    output vector direction = 0,
    output color throughput = 1)
{
    // Sensor size from Blender camera
    vector sensor_size = 0;
    getattribute("cam:sensor_size", sensor_size);
    float sensor_w = sensor_size[0];
    float sensor_h = sensor_size[1];

    // Raster position (0-1 range)
    point raster = camera_shader_raster_position();
    float rx = raster[0];
    float ry = raster[1];

    // Map raster coordinates to physical sensor position (mm).
    // Negate to compensate for lens inversion (real lenses flip the image).
    float sensor_x = (0.5 - rx) * sensor_w;
    float sensor_y = (0.5 - ry) * sensor_h;

    // Debug mode 1: pinhole camera to verify the framework
    // +Z is the view direction in Blender's OSL camera convention
    if (debug_mode >= 0.5 && debug_mode < 1.5) {
        position = point(0, 0, 0);
        direction = normalize(vector(sensor_x, sensor_y, 50.0));
        throughput = 1.0;
        return;
    }

    // Load lens data
    float radii[MAX_SURFACES];
    float thicknesses[MAX_SURFACES];
    float iors[MAX_SURFACES];
    float apertures[MAX_SURFACES];
    float abbe_v[MAX_SURFACES];
    int num_surfaces = 0;
    int stop_index = 0;
    load_lens_data(lens_type, radii, thicknesses, iors, apertures, abbe_v,
                   num_surfaces, stop_index);

    // Random sample for DOF
    point rnd = camera_shader_random_sample();

    // Compute total lens length
    float total_length = 0.0;
    for (int i = 0; i < num_surfaces - 1; i++)
        total_length += thicknesses[i];

    // Lens layout: rear element at z=0, front element at z=-total_length.
    // Sensor is behind the rear element at z = +sensor_distance.
    float sensor_z = sensor_distance;
    point sensor_point = point(sensor_x, sensor_y, sensor_z);

    // Compute the aperture stop's z-position
    float stop_z = -total_length;
    for (int i = 0; i < stop_index; i++)
        stop_z += thicknesses[i];

    // Sample on the aperture stop plane so rays pass through the physical stop
    float stop_semi_ap = apertures[stop_index] * 0.5 * aperture_scale;
    float angle = rnd[0] * 2.0 * M_PI;
    float r_sample = sqrt(rnd[1]) * stop_semi_ap;
    float ax = r_sample * cos(angle);
    float ay = r_sample * sin(angle);
    point aperture_point = point(ax, ay, stop_z);

    // Initial ray: sensor toward the stop
    vector initial_dir = normalize(aperture_point - sensor_point);

    // Trace through the lens system
    point  exit_origin = point(0, 0, 0);
    vector exit_dir = vector(0, 0, 0);
    int surfaces_passed = 0;
    int failure_type = 0;

    int ok = trace_lens_system(sensor_point, initial_dir, aperture_scale,
                               num_surfaces, stop_index,
                               radii, thicknesses, iors, apertures,
                               exit_origin, exit_dir, surfaces_passed, failure_type);

    // Debug mode 2: failure cause diagnostic.
    // White = all passed.
    // Green = aperture clip, Blue = TIR, Red = intersection miss.
    // Brightness = how far the ray got.
    if (debug_mode >= 1.5 && debug_mode < 2.5) {
        position = point(0, 0, 0);
        direction = normalize(vector(sensor_x, sensor_y, 50.0));
        if (ok) {
            throughput = color(1, 1, 1);
        } else {
            float brightness = float(surfaces_passed) / float(num_surfaces);
            float is_clip = (failure_type == 2) ? brightness : 0.0;
            float is_tir = (failure_type == 3) ? brightness : 0.0;
            float is_miss = (failure_type == 1) ? brightness : 0.0;
            throughput = color(is_miss, is_clip, is_tir);
        }
        return;
    }

    // Debug mode 3: exit direction as RGB (only for rays that survive)
    if (debug_mode >= 2.5 && debug_mode < 3.5) {
        if (ok) {
            vector d_norm = normalize(exit_dir);
            position = point(0, 0, 0);
            direction = normalize(vector(sensor_x, sensor_y, 50.0));
            throughput = color(d_norm[0] * 0.5 + 0.5,
                               d_norm[1] * 0.5 + 0.5,
                               d_norm[2] * 0.5 + 0.5);
        } else {
            throughput = 0.0;
        }
        return;
    }

    // Normal mode: output in camera space (Blender applies camera transform).
    // Lens space has -z toward scene; Blender camera space has +z toward scene.
    // Negate z to convert.
    if (ok) {
        position = point(exit_origin[0] * 0.001,
                         exit_origin[1] * 0.001,
                         -exit_origin[2] * 0.001);
        direction = normalize(vector(exit_dir[0], exit_dir[1], -exit_dir[2]));
        throughput = 1.0;
    } else {
        throughput = 0.0;
    }
}
