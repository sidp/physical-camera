#define MAX_SURFACES 24

void load_lens_data(
    int lens_type,
    output float radii[MAX_SURFACES],
    output float thicknesses[MAX_SURFACES],
    output float iors[MAX_SURFACES],
    output float apertures[MAX_SURFACES],
    output float abbe_v[MAX_SURFACES],
    output int num_surfaces,
    output int stop_index)
{
    if (lens_type == 0) {
        // Double Gauss 50mm f/2 (PBRT, US Patent 2,673,491)
        // Listed front-to-back (scene-side to sensor-side)
        num_surfaces = 11;
        stop_index = 5;
        radii[0]  =  29.475;  thicknesses[0]  = 3.76;  iors[0]  = 1.67;  apertures[0]  = 25.2;  abbe_v[0]  = 57.0;
        radii[1]  =  84.83;   thicknesses[1]  = 0.12;  iors[1]  = 1.0;   apertures[1]  = 25.2;  abbe_v[1]  = 0.0;
        radii[2]  =  19.275;  thicknesses[2]  = 4.025; iors[2]  = 1.67;  apertures[2]  = 23.0;  abbe_v[2]  = 57.0;
        radii[3]  =  40.77;   thicknesses[3]  = 3.275; iors[3]  = 1.699; apertures[3]  = 23.0;  abbe_v[3]  = 30.0;
        radii[4]  =  12.75;   thicknesses[4]  = 5.705; iors[4]  = 1.0;   apertures[4]  = 18.0;  abbe_v[4]  = 0.0;
        radii[5]  =   0.0;    thicknesses[5]  = 4.5;   iors[5]  = 1.0;   apertures[5]  = 17.1;  abbe_v[5]  = 0.0;
        radii[6]  = -14.495;  thicknesses[6]  = 1.18;  iors[6]  = 1.603; apertures[6]  = 17.0;  abbe_v[6]  = 38.0;
        radii[7]  =  40.77;   thicknesses[7]  = 6.065; iors[7]  = 1.658; apertures[7]  = 20.0;  abbe_v[7]  = 50.0;
        radii[8]  = -20.385;  thicknesses[8]  = 0.19;  iors[8]  = 1.0;   apertures[8]  = 20.0;  abbe_v[8]  = 0.0;
        radii[9]  = 437.065;  thicknesses[9]  = 3.22;  iors[9]  = 1.717; apertures[9]  = 20.0;  abbe_v[9]  = 48.0;
        radii[10] = -39.73;   thicknesses[10] = 0.0;   iors[10] = 1.0;   apertures[10] = 20.0;  abbe_v[10] = 0.0;
    }
    else if (lens_type == 1) {
        // Double Gauss 100mm f/1.7 (US Patent 2,784,643)
        num_surfaces = 11;
        stop_index = 5;
        radii[0]  =  75.050;  thicknesses[0]  =  9.000;  iors[0]  = 1.717;  apertures[0]  = 66.0;  abbe_v[0]  = 47.9;
        radii[1]  = 270.700;  thicknesses[1]  =  0.100;  iors[1]  = 1.0;    apertures[1]  = 66.0;  abbe_v[1]  =  0.0;
        radii[2]  =  39.270;  thicknesses[2]  = 16.510;  iors[2]  = 1.667;  apertures[2]  = 55.0;  abbe_v[2]  = 48.3;
        radii[3]  =   0.0;    thicknesses[3]  =  2.000;  iors[3]  = 1.673;  apertures[3]  = 49.0;  abbe_v[3]  = 32.25;
        radii[4]  =  25.650;  thicknesses[4]  = 10.990;  iors[4]  = 1.0;    apertures[4]  = 39.0;  abbe_v[4]  =  0.0;
        radii[5]  =   0.0;    thicknesses[5]  = 13.000;  iors[5]  = 1.0;    apertures[5]  = 37.2;  abbe_v[5]  =  0.0;
        radii[6]  = -31.870;  thicknesses[6]  =  7.030;  iors[6]  = 1.673;  apertures[6]  = 37.0;  abbe_v[6]  = 32.25;
        radii[7]  =   0.0;    thicknesses[7]  =  8.980;  iors[7]  = 1.717;  apertures[7]  = 42.0;  abbe_v[7]  = 47.9;
        radii[8]  = -43.510;  thicknesses[8]  =  0.100;  iors[8]  = 1.0;    apertures[8]  = 42.0;  abbe_v[8]  =  0.0;
        radii[9]  = 221.140;  thicknesses[9]  =  7.980;  iors[9]  = 1.667;  apertures[9]  = 46.0;  abbe_v[9]  = 48.3;
        radii[10] = -88.790;  thicknesses[10] =  0.0;    iors[10] = 1.0;    apertures[10] = 46.0;  abbe_v[10] =  0.0;
    }
}

// Compute wavelength-dependent IOR using Cauchy-like dispersion from Abbe number.
// channel: 0 = red (656.3nm, C line), 1 = green (587.6nm, d line), 2 = blue (486.1nm, F line)
// For air (n_d = 1.0 or abbe_v = 0), returns n_d unchanged.
float disperse_ior(float n_d, float v_d, int channel)
{
    if (v_d < 1.0 || n_d <= 1.0)
        return n_d;

    // delta = (n_F - n_C) / 2, derived from Abbe number definition: V = (n_d - 1) / (n_F - n_C)
    float delta = (n_d - 1.0) / (2.0 * v_d);

    if (channel == 0) return n_d - delta;  // red: lower IOR
    if (channel == 2) return n_d + delta;  // blue: higher IOR
    return n_d;                            // green: nominal
}

float fresnel_transmittance(float n1, float n2, float cos_i, float cos_t)
{
    if (n1 == n2)
        return 1.0;
    float rs = (n1 * cos_i - n2 * cos_t) / (n1 * cos_i + n2 * cos_t);
    float rp = (n1 * cos_t - n2 * cos_i) / (n1 * cos_t + n2 * cos_i);
    return 1.0 - (rs * rs + rp * rp) * 0.5;
}

float onaxis_fresnel_transmission(
    int num_surfaces,
    float radii[MAX_SURFACES],
    float iors[MAX_SURFACES])
{
    float T = 1.0;
    for (int idx = num_surfaces - 1; idx >= 0; idx--) {
        float n1 = iors[idx];
        float n2 = (idx > 0) ? iors[idx - 1] : 1.0;
        if (n1 == n2)
            continue;
        float r = (n1 - n2) / (n1 + n2);
        T *= 1.0 - r * r;
    }
    return T;
}

float compute_sensor_distance(
    int num_surfaces,
    float radii[MAX_SURFACES],
    float thicknesses[MAX_SURFACES],
    float iors[MAX_SURFACES],
    float total_length,
    float focus_mm)
{
    // Build ABCD system matrix by front-to-back paraxial ray trace.
    // Convention: M = [[A,B],[C,D]], initialized to identity.
    float A = 1.0, B = 0.0, C = 0.0, D = 1.0;

    for (int i = 0; i < num_surfaces; i++) {
        float n_before = (i == 0) ? 1.0 : iors[i - 1];
        float n_after = iors[i];

        // Refraction matrix (skip flat surfaces and matching IOR)
        if (radii[i] != 0.0 && n_before != n_after) {
            float phi = (n_after - n_before) / radii[i];
            C -= phi * A;
            D -= phi * B;
        }

        // Transfer matrix (skip after last surface)
        if (i < num_surfaces - 1) {
            float t = thicknesses[i] / iors[i];
            A += t * C;
            B += t * D;
        }
    }

    // Fall back to infinity focus if the system has no optical power
    if (abs(C) < 1e-10)
        return -A / C;

    float f = -1.0 / C;
    float bfd = -A / C;
    float rpp = (1.0 - A) / C;
    float fpp = (D - 1.0) / C;

    if (focus_mm <= 0.0)
        return bfd;

    float d_o = focus_mm - total_length + fpp;
    if (d_o <= f)
        return bfd;

    float d_i = f * d_o / (d_o - f);
    return rpp + d_i;
}

void compute_exit_pupil(
    int num_surfaces,
    int stop_index,
    float radii[MAX_SURFACES],
    float thicknesses[MAX_SURFACES],
    float iors[MAX_SURFACES],
    output float ep_z,
    output float ep_magnification)
{
    // Build ABCD matrix for the rear subsystem (stop -> rear vertex).
    // This gives the exit pupil position and magnification relative to the
    // physical aperture stop, so we can aim rays at the apparent opening.
    float A = 1.0, B = 0.0, C = 0.0, D = 1.0;

    // Initial transfer from stop to first rear surface
    float t = thicknesses[stop_index] / iors[stop_index];
    A += t * C;
    B += t * D;

    for (int i = stop_index + 1; i < num_surfaces; i++) {
        float n_before = iors[i - 1];
        float n_after = iors[i];

        // Refraction
        if (radii[i] != 0.0 && n_before != n_after) {
            float phi = (n_after - n_before) / radii[i];
            C -= phi * A;
            D -= phi * B;
        }

        // Transfer (skip after last surface)
        if (i < num_surfaces - 1) {
            t = thicknesses[i] / iors[i];
            A += t * C;
            B += t * D;
        }
    }

    if (abs(D) < 1e-10) {
        ep_z = 0.0;
        ep_magnification = 0.0;
        return;
    }

    ep_z = -B / D;
    ep_magnification = abs(1.0 / D);
}

int point_in_ngon(float x, float y, float semi_ap, int num_blades, float rotation_rad)
{
    float r = sqrt(x * x + y * y);
    if (r < 1e-10)
        return 1;
    float sector_angle = 2.0 * M_PI / float(num_blades);
    float angle = atan2(y, x) - rotation_rad;
    angle = angle - floor(angle / (2.0 * M_PI)) * 2.0 * M_PI;
    float theta = mod(angle, sector_angle) - sector_angle * 0.5;
    float max_r = semi_ap * cos(M_PI / float(num_blades)) / cos(theta);
    return (r <= max_r) ? 1 : 0;
}

int intersect_sphere(
    point ray_origin,
    vector ray_dir,
    float sphere_center_z,
    float radius,
    output point hit_point)
{
    float ox = ray_origin[0];
    float oy = ray_origin[1];
    float oz = ray_origin[2] - sphere_center_z;
    float dx = ray_dir[0];
    float dy = ray_dir[1];
    float dz = ray_dir[2];

    float a = dx * dx + dy * dy + dz * dz;
    float b = 2.0 * (ox * dx + oy * dy + oz * dz);
    float c = ox * ox + oy * oy + oz * oz - radius * radius;

    float disc = b * b - 4.0 * a * c;
    if (disc < 0.0)
        return 0;

    float sqrt_disc = sqrt(disc);
    float t1 = (-b - sqrt_disc) / (2.0 * a);
    float t2 = (-b + sqrt_disc) / (2.0 * a);

    // Pick the intersection closest to the vertex (sphere_center_z - radius).
    // Do NOT fall back to the far-side intersection — if the vertex-side hit
    // is behind the ray, the ray has passed this surface and should be rejected.
    float vertex_z = sphere_center_z - radius;
    point p1 = ray_origin + t1 * ray_dir;
    point p2 = ray_origin + t2 * ray_dir;

    float dist1 = abs(p1[2] - vertex_z);
    float dist2 = abs(p2[2] - vertex_z);

    if (dist1 < dist2) {
        if (t1 > 1e-6) {
            hit_point = p1;
            return 1;
        }
    } else {
        if (t2 > 1e-6) {
            hit_point = p2;
            return 1;
        }
    }

    return 0;
}

// Returns: 1 = success, 0 = intersection miss, -1 = aperture clip, -2 = TIR
int refract_at_surface(
    point ray_origin,
    vector ray_dir,
    float vertex_z,
    float radius,
    float semi_aperture,
    float n1,
    float n2,
    int num_blades,
    float blade_rotation,
    int is_stop,
    output point new_origin,
    output vector new_dir,
    output float transmission)
{
    if (radius == 0.0) {
        float dz = ray_dir[2];
        if (abs(dz) < 1e-10)
            return 0;
        float t = (vertex_z - ray_origin[2]) / dz;
        if (t < 1e-6)
            return 0;
        new_origin = ray_origin + t * ray_dir;

        if (is_stop) {
            // Aperture stop: shaped clipping, no refraction
            if (num_blades >= 3) {
                if (!point_in_ngon(new_origin[0], new_origin[1], semi_aperture, num_blades, blade_rotation))
                    return -1;
            } else {
                float r = sqrt(new_origin[0] * new_origin[0] + new_origin[1] * new_origin[1]);
                if (r > semi_aperture)
                    return -1;
            }
            new_dir = ray_dir;
            transmission = 1.0;
            return 1;
        }

        // Flat refractive surface: circular clip + Snell's law
        float r = sqrt(new_origin[0] * new_origin[0] + new_origin[1] * new_origin[1]);
        if (r > semi_aperture)
            return -1;

        if (n1 == n2) {
            new_dir = ray_dir;
            transmission = 1.0;
            return 1;
        }

        vector N = vector(0, 0, -1);
        vector I = normalize(ray_dir);
        if (dot(I, N) > 0.0)
            N = -N;
        float cos_i = abs(dot(I, N));
        vector refracted = refract(I, N, n1 / n2);
        if (dot(refracted, refracted) < 1e-10)
            return -2;
        float cos_t = abs(dot(refracted, N));
        transmission = fresnel_transmittance(n1, n2, cos_i, cos_t);
        new_dir = refracted;
        return 1;
    }

    float sphere_center_z = vertex_z + radius;
    point hit = point(0, 0, 0);

    if (!intersect_sphere(ray_origin, ray_dir, sphere_center_z, radius, hit))
        return 0;

    // Aperture clip
    float r = sqrt(hit[0] * hit[0] + hit[1] * hit[1]);
    if (r > semi_aperture)
        return -1;

    // Surface normal: points from sphere center to hit point
    vector N = normalize(hit - point(0, 0, sphere_center_z));

    // Flip normal to face the incoming ray
    vector I = normalize(ray_dir);
    if (dot(I, N) > 0.0)
        N = -N;

    float cos_i = abs(dot(I, N));
    float eta = n1 / n2;
    vector refracted = refract(I, N, eta);

    // TIR check: refract() returns zero vector on total internal reflection
    if (dot(refracted, refracted) < 1e-10)
        return -2;

    float cos_t = abs(dot(refracted, N));
    transmission = (n1 == n2) ? 1.0 : fresnel_transmittance(n1, n2, cos_i, cos_t);

    new_origin = hit;
    new_dir = refracted;
    return 1;
}

// failure_type output: 0 = success, 1 = intersection miss, 2 = aperture clip, 3 = TIR
int trace_lens_system(
    point ray_origin,
    vector ray_dir,
    float aperture_scale,
    int num_surfaces,
    int stop_index,
    float radii[MAX_SURFACES],
    float thicknesses[MAX_SURFACES],
    float iors[MAX_SURFACES],
    float apertures[MAX_SURFACES],
    float abbe_v[MAX_SURFACES],
    int channel,
    int num_blades,
    float blade_rotation,
    output point exit_origin,
    output vector exit_dir,
    output int surfaces_passed,
    output int failure_type,
    output float total_transmission)
{
    surfaces_passed = 0;
    failure_type = 0;
    total_transmission = 1.0;

    // Compute vertex z-positions (PBRT convention: front at most negative z,
    // rear at z=0). This ensures sphere curvature pushes off-axis hits away
    // from subsequent surfaces, preventing overshoot at thin air gaps.
    float vertex_z[MAX_SURFACES];
    float total_length = 0.0;
    for (int i = 0; i < num_surfaces - 1; i++)
        total_length += thicknesses[i];

    vertex_z[0] = -total_length;
    for (int i = 1; i < num_surfaces; i++)
        vertex_z[i] = vertex_z[i - 1] + thicknesses[i - 1];

    point  p = ray_origin;
    vector d = ray_dir;

    // Trace rear-to-front: last surface down to surface 0
    for (int idx = num_surfaces - 1; idx >= 0; idx--) {
        float semi_ap = apertures[idx] * 0.5;

        if (idx == stop_index)
            semi_ap *= aperture_scale;

        // iors[i] = IOR of the medium between surface i and surface i+1
        // (toward sensor). When tracing sensor→scene at surface idx:
        // n1 = medium the ray is in (sensor side) = iors[idx]
        // n2 = medium the ray enters (scene side) = iors[idx-1] or air
        float n1 = disperse_ior(iors[idx], abbe_v[idx], channel);
        float n2 = (idx > 0) ? disperse_ior(iors[idx - 1], abbe_v[idx - 1], channel) : 1.0;

        // No refraction at aperture stop
        if (idx == stop_index) {
            n1 = 1.0;
            n2 = 1.0;
        }

        int is_stop = (idx == stop_index) ? 1 : 0;

        point  new_p = point(0, 0, 0);
        vector new_d = vector(0, 0, 0);
        float surface_transmission = 1.0;

        int result = refract_at_surface(p, d, vertex_z[idx], radii[idx], semi_ap, n1, n2, num_blades, blade_rotation, is_stop, new_p, new_d, surface_transmission);
        if (result != 1) {
            if (result == 0) failure_type = 1;
            else if (result == -1) failure_type = 2;
            else if (result == -2) failure_type = 3;
            return 0;
        }

        surfaces_passed += 1;
        total_transmission *= surface_transmission;
        p = new_p;
        d = new_d;
    }

    exit_origin = p;
    exit_dir = d;
    return 1;
}

shader lens_camera(
    float aperture_scale = 1.0
        [[ string description = "Scale factor for the aperture stop opening. 1.0 = wide open." ]],
    int lens_type = 0
        [[ string description = "Lens selection. 0 = Double Gauss 50mm f/2, 1 = Double Gauss 100mm f/1.7." ]],
    int aperture_blades = 0
        [[ string description = "Number of aperture blades. 0 = circular." ]],
    float blade_rotation = 0.0
        [[ string description = "Aperture blade rotation in degrees." ]],
    float debug_mode = 0.0
        [[ string description = "0=normal, 1=pinhole, 2=surface count, 3=exit direction" ]],
    output point position = 0,
    output vector direction = 0,
    output color throughput = 1)
{
    // Sensor size from Blender camera
    vector sensor_size = 0;
    getattribute("cam:sensor_size", sensor_size);
    float sensor_w = sensor_size[0];
    float sensor_h = sensor_size[1];

    float focal_distance = 0.0;
    getattribute("cam:focal_distance", focal_distance);

    // Raster position (0-1 range)
    point raster = camera_shader_raster_position();
    float rx = raster[0];
    float ry = raster[1];

    // Map raster coordinates to physical sensor position (mm).
    // Negate to compensate for lens inversion (real lenses flip the image).
    float sensor_x = (0.5 - rx) * sensor_w;
    float sensor_y = (0.5 - ry) * sensor_h;

    // Debug mode 1: pinhole camera to verify the framework
    // +Z is the view direction in Blender's OSL camera convention
    if (debug_mode >= 0.5 && debug_mode < 1.5) {
        position = point(0, 0, 0);
        direction = normalize(vector(sensor_x, sensor_y, 50.0));
        throughput = 1.0;
        return;
    }

    // Load lens data
    float radii[MAX_SURFACES];
    float thicknesses[MAX_SURFACES];
    float iors[MAX_SURFACES];
    float apertures[MAX_SURFACES];
    float abbe_v[MAX_SURFACES];
    int num_surfaces = 0;
    int stop_index = 0;
    load_lens_data(lens_type, radii, thicknesses, iors, apertures, abbe_v,
                   num_surfaces, stop_index);

    float onaxis_T = onaxis_fresnel_transmission(num_surfaces, radii, iors);

    float total_length = 0.0;
    for (int i = 0; i < num_surfaces - 1; i++)
        total_length += thicknesses[i];

    float focus_mm = focal_distance * 1000.0;
    float sensor_distance = compute_sensor_distance(
        num_surfaces, radii, thicknesses, iors, total_length, focus_mm);

    // Random sample for DOF and wavelength selection.
    // camera_shader_random_sample() provides two independent uniform values in x/y.
    // We use x for the aperture angle and split y into channel selection + radius.
    point rnd = camera_shader_random_sample();

    // Monte Carlo wavelength: pick one of R/G/B per sample.
    // Split rnd[1] into channel choice (3 bins) and a radius parameter.
    int channel = int(floor(rnd[1] * 3.0));
    if (channel > 2) channel = 2;
    float r_param = rnd[1] * 3.0 - float(channel);

    // Lens layout: rear element at z=0, front element at z=-total_length.
    // Sensor is behind the rear element at z = +sensor_distance.
    float sensor_z = sensor_distance;
    point sensor_point = point(sensor_x, sensor_y, sensor_z);

    // Compute the aperture stop's z-position
    float stop_z = -total_length;
    for (int i = 0; i < stop_index; i++)
        stop_z += thicknesses[i];

    // Sample on the exit pupil plane to reduce wasted rays for off-axis points.
    // The exit pupil is the image of the aperture stop as seen through the rear
    // lens group — it differs in position and size from the physical stop.
    float stop_semi_ap = apertures[stop_index] * 0.5 * aperture_scale;

    float ep_z = 0.0;
    float ep_magnification = 1.0;
    compute_exit_pupil(num_surfaces, stop_index, radii, thicknesses, iors,
                       ep_z, ep_magnification);
    float aim_z = (ep_magnification > 0.0) ? ep_z : stop_z;
    float aim_semi_ap = (ep_magnification > 0.0) ? stop_semi_ap * ep_magnification : stop_semi_ap;

    float blade_rot_rad = blade_rotation * M_PI / 180.0;
    float ax = 0.0;
    float ay = 0.0;

    if (aperture_blades >= 3) {
        int n = aperture_blades;
        float sector_angle = 2.0 * M_PI / float(n);
        int sector = int(floor(rnd[0] * float(n)));
        if (sector >= n) sector = n - 1;
        float u1 = rnd[0] * float(n) - float(sector);
        float u2 = r_param;
        if (u1 + u2 > 1.0) {
            u1 = 1.0 - u1;
            u2 = 1.0 - u2;
        }
        float a0 = blade_rot_rad + float(sector) * sector_angle;
        float a1 = blade_rot_rad + float(sector + 1) * sector_angle;
        ax = u1 * aim_semi_ap * cos(a0) + u2 * aim_semi_ap * cos(a1);
        ay = u1 * aim_semi_ap * sin(a0) + u2 * aim_semi_ap * sin(a1);
    } else {
        float angle = rnd[0] * 2.0 * M_PI;
        float r_sample = sqrt(r_param) * aim_semi_ap;
        ax = r_sample * cos(angle);
        ay = r_sample * sin(angle);
    }

    point aperture_point = point(ax, ay, aim_z);

    // Initial ray: sensor toward the stop
    vector initial_dir = normalize(aperture_point - sensor_point);

    // Trace through the lens system
    point  exit_origin = point(0, 0, 0);
    vector exit_dir = vector(0, 0, 0);
    int surfaces_passed = 0;
    int failure_type = 0;
    float total_transmission = 0.0;

    int ok = trace_lens_system(sensor_point, initial_dir, aperture_scale,
                               num_surfaces, stop_index,
                               radii, thicknesses, iors, apertures,
                               abbe_v, channel,
                               aperture_blades, blade_rot_rad,
                               exit_origin, exit_dir, surfaces_passed, failure_type,
                               total_transmission);

    // Debug mode 2: failure cause diagnostic.
    // White = all passed.
    // Green = aperture clip, Blue = TIR, Red = intersection miss.
    // Brightness = how far the ray got.
    if (debug_mode >= 1.5 && debug_mode < 2.5) {
        position = point(0, 0, 0);
        direction = normalize(vector(sensor_x, sensor_y, 50.0));
        if (ok) {
            throughput = color(1, 1, 1);
        } else {
            float brightness = float(surfaces_passed) / float(num_surfaces);
            float is_clip = (failure_type == 2) ? brightness : 0.0;
            float is_tir = (failure_type == 3) ? brightness : 0.0;
            float is_miss = (failure_type == 1) ? brightness : 0.0;
            throughput = color(is_miss, is_clip, is_tir);
        }
        return;
    }

    // Debug mode 3: exit direction as RGB (only for rays that survive)
    if (debug_mode >= 2.5 && debug_mode < 3.5) {
        if (ok) {
            vector d_norm = normalize(exit_dir);
            position = point(0, 0, 0);
            direction = normalize(vector(sensor_x, sensor_y, 50.0));
            throughput = color(d_norm[0] * 0.5 + 0.5,
                               d_norm[1] * 0.5 + 0.5,
                               d_norm[2] * 0.5 + 0.5);
        } else {
            throughput = 0.0;
        }
        return;
    }

    // Normal mode: output in camera space (Blender applies camera transform).
    // Lens space has -z toward scene; Blender camera space has +z toward scene.
    // Negate z to convert.
    if (ok) {
        // Throughput weight: cos^4(theta) models natural radiometric falloff.
        vector axis = vector(0, 0, -1);
        float cos_theta = dot(normalize(initial_dir), axis);
        float weight = cos_theta * cos_theta * cos_theta * cos_theta;

        // Each sample traces one wavelength (R, G, or B). Multiply by 3 to
        // compensate for the 1/3 probability of selecting each channel.
        float w = weight * (total_transmission / onaxis_T) * 3.0;
        float wr = (channel == 0) ? w : 0.0;
        float wg = (channel == 1) ? w : 0.0;
        float wb = (channel == 2) ? w : 0.0;

        position = point(exit_origin[0] * 0.001,
                         exit_origin[1] * 0.001,
                         -exit_origin[2] * 0.001);
        direction = normalize(vector(exit_dir[0], exit_dir[1], -exit_dir[2]));
        throughput = color(wr, wg, wb);
    } else {
        throughput = 0.0;
    }
}
