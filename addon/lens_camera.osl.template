// {{LENS_DATA}}

// {{SCENE_LIGHTS}}

// Cauchy dispersion: n(λ) = A + B/λ², coefficients derived from n_d and Abbe number.
float cauchy_ior(float n_d, float v_d, float lambda_nm)
{
    if (v_d < 1.0 || n_d <= 1.0)
        return n_d;

    float inv_lF2 = 1.0 / (486.1 * 486.1);
    float inv_lC2 = 1.0 / (656.3 * 656.3);
    float inv_ld2 = 1.0 / (587.6 * 587.6);
    float B = (n_d - 1.0) / (v_d * (inv_lF2 - inv_lC2));
    float A = n_d - B * inv_ld2;
    return A + B / (lambda_nm * lambda_nm);
}

color wavelength_to_rgb(float lambda)
{
    // Wyman et al. 2013 piecewise Gaussian fits to CIE 1931 XYZ
    float t1 = (lambda - 442.0) * ((lambda < 442.0) ? 0.0624 : 0.0374);
    float t2 = (lambda - 599.8) * ((lambda < 599.8) ? 0.0264 : 0.0323);
    float t3 = (lambda - 501.1) * ((lambda < 501.1) ? 0.0490 : 0.0382);
    float x = 0.362 * exp(-0.5*t1*t1) + 1.056 * exp(-0.5*t2*t2) - 0.065 * exp(-0.5*t3*t3);

    float t4 = (lambda - 568.8) * ((lambda < 568.8) ? 0.0213 : 0.0247);
    float t5 = (lambda - 530.9) * ((lambda < 530.9) ? 0.0613 : 0.0322);
    float y = 0.821 * exp(-0.5*t4*t4) + 0.286 * exp(-0.5*t5*t5);

    float t6 = (lambda - 437.0) * ((lambda < 437.0) ? 0.0845 : 0.0278);
    float t7 = (lambda - 459.0) * ((lambda < 459.0) ? 0.0385 : 0.0725);
    float z = 1.217 * exp(-0.5*t6*t6) + 0.681 * exp(-0.5*t7*t7);

    // XYZ -> linear sRGB (D65)
    float r =  3.2406 * x - 1.5372 * y - 0.4986 * z;
    float g = -0.9689 * x + 1.8758 * y + 0.0415 * z;
    float b =  0.0557 * x - 0.2040 * y + 1.0570 * z;

    return color(max(r, 0.0), max(g, 0.0), max(b, 0.0));
}

// Thin-film interference reflectance for coated/uncoated surfaces.
// Returns the actual reflectance R (fraction of power reflected).
float coated_reflectance(float n1, float n2, float cos_i, float cos_t,
                         float lambda_nm, float coating)
{
    if (n1 == n2)
        return 0.0;

    // Bare Fresnel reflectance (s and p polarization averaged)
    float rs = (n1 * cos_i - n2 * cos_t) / (n1 * cos_i + n2 * cos_t);
    float rp = (n1 * cos_t - n2 * cos_i) / (n1 * cos_t + n2 * cos_i);
    float R_bare = (rs * rs + rp * rp) * 0.5;

    // Uncoated or cemented (glass-glass interface): bare Fresnel only
    if (coating < 0.5 || min(n1, n2) >= 1.01)
        return R_bare;

    // Quarter-wave MgF2 thin-film coating (Airy formula)
    float nc = 1.38;
    float lambda0 = 550.0;
    float lo = min(n1, n2);
    float hi = max(n1, n2);

    // Snell's law into the coating layer (cos_i is measured in medium n1)
    float sin_i2 = 1.0 - cos_i * cos_i;
    float sin_c2 = (n1 * n1) / (nc * nc) * sin_i2;
    float cos_c = (sin_c2 < 1.0) ? sqrt(1.0 - sin_c2) : 0.0;

    // Round-trip phase through the coating
    float delta = M_PI * (lambda0 / lambda_nm) * cos_c;

    // Amplitude reflection coefficients at coating interfaces
    float r1 = (lo - nc) / (lo + nc);
    float r2 = (nc - hi) / (nc + hi);

    // Airy formula for thin-film reflectance
    float cos_d = cos(delta);
    float r1r2 = r1 * r2;
    float R_film = (r1 * r1 + r2 * r2 + 2.0 * r1r2 * cos_d)
                 / (1.0 + r1r2 * r1r2 + 2.0 * r1r2 * cos_d);

    if (coating < 1.5)
        return R_film;

    // Multicoating: power-law boost deepens the on-design minimum while
    // preserving the spectral and angular shape from the Airy formula.
    // Clamped to bare Fresnel — real multicoatings never exceed uncoated.
    float R_normal = (lo - hi) * (lo - hi) / ((lo + hi) * (lo + hi));
    float ratio = (R_normal > 1e-10) ? R_film / R_normal : 1.0;
    return min(R_normal * ratio * ratio * ratio, R_bare);
}

float fresnel_transmittance(float n1, float n2, float cos_i, float cos_t,
                            float lambda_nm, float coating)
{
    if (n1 == n2)
        return 1.0;
    return 1.0 - coated_reflectance(n1, n2, cos_i, cos_t, lambda_nm, coating);
}

int point_in_ngon(float x, float y, float semi_ap, int num_blades, float rotation_rad)
{
    float r = sqrt(x * x + y * y);
    if (r < 1e-10)
        return 1;
    float sector_angle = 2.0 * M_PI / float(num_blades);
    float angle = atan2(y, x) - rotation_rad;
    angle = angle - floor(angle / (2.0 * M_PI)) * 2.0 * M_PI;
    float theta = mod(angle, sector_angle) - sector_angle * 0.5;
    float max_r = semi_ap * cos(M_PI / float(num_blades)) / cos(theta);
    return (r <= max_r) ? 1 : 0;
}

// Project ray to a z-plane and check circular or n-gon aperture.
// Returns 1 if the ray passes, 0 if projection fails, -1 if clipped.
// Sets out_p to the projected point on success.
int check_aperture_at_plane(
    point p, vector d,
    float plane_z, float semi_aperture,
    int surface_type, int num_blades, float blade_rotation,
    output point out_p)
{
    if (abs(d[2]) <= 1e-10)
        return 0;

    float t = (plane_z - p[2]) / d[2];
    float hx = p[0] + t * d[0];
    float hy = p[1] + t * d[1];

    if (surface_type == SURFACE_STOP && num_blades >= 3) {
        if (!point_in_ngon(hx, hy, semi_aperture, num_blades, blade_rotation))
            return -1;
    } else {
        float r = sqrt(hx * hx + hy * hy);
        if (r > semi_aperture)
            return -1;
    }

    out_p = point(hx, hy, plane_z);
    return 1;
}

// Snell's law at a flat surface with Fresnel transmittance.
// Returns 1 on success, 0 on TIR.
int refract_at_flat_plane(
    vector d_in, float n1, float n2, float lambda_nm, float coating,
    output vector d_out, output float transmission)
{
    if (n1 == n2) {
        d_out = d_in;
        transmission = 1.0;
        return 1;
    }

    vector N = vector(0, 0, -1);
    vector I = normalize(d_in);
    if (dot(I, N) > 0.0)
        N = -N;
    float cos_i = abs(dot(I, N));
    vector refracted = refract(I, N, n1 / n2);
    if (dot(refracted, refracted) < 1e-10)
        return 0;
    float cos_t = abs(dot(refracted, N));
    transmission = fresnel_transmittance(n1, n2, cos_i, cos_t, lambda_nm, coating);
    d_out = refracted;
    return 1;
}

float onaxis_fresnel_transmission(
    int num_surfaces,
    float radii[MAX_SURFACES],
    float iors[MAX_SURFACES],
    float lambda_nm,
    float coating)
{
    float T = 1.0;
    for (int idx = num_surfaces - 1; idx >= 0; idx--) {
        float n1 = iors[idx];
        float n2 = (idx > 0) ? iors[idx - 1] : 1.0;
        if (n1 == n2)
            continue;
        float R = coated_reflectance(n1, n2, 1.0, 1.0, lambda_nm, coating);
        T *= 1.0 - R;
    }
    return T;
}

int is_curved_surface(int surface_type) {
    return (surface_type == SURFACE_SPHERICAL || surface_type == SURFACE_ASPHERIC
            || surface_type == SURFACE_CYLINDRICAL_X || surface_type == SURFACE_CYLINDRICAL_Y);
}

float compute_sensor_distance(
    int num_surfaces,
    float radii[MAX_SURFACES],
    float thicknesses[MAX_SURFACES],
    float iors[MAX_SURFACES],
    int surface_types[MAX_SURFACES],
    float total_length,
    float focus_mm)
{
    // Build ABCD system matrix by front-to-back paraxial ray trace (Y axis).
    // For anamorphic lenses, sensor distance is derived from Y (spherical
    // meridian) — matching how cinematographers focus anamorphic lenses.
    // Cylindrical_x surfaces have no power in Y; cylindrical_y surfaces do.
    float A = 1.0, B = 0.0, C = 0.0, D = 1.0;

    for (int i = 0; i < num_surfaces; i++) {
        float n_before = (i == 0) ? 1.0 : iors[i - 1];
        float n_after = iors[i];

        // Refraction matrix — skip surfaces with no Y-axis power
        if (is_curved_surface(surface_types[i]) && n_before != n_after
            && surface_types[i] != SURFACE_CYLINDRICAL_X) {
            float phi = (n_after - n_before) / radii[i];
            C -= phi * A;
            D -= phi * B;
        }

        // Transfer matrix (skip after last surface)
        if (i < num_surfaces - 1) {
            float t = thicknesses[i] / iors[i];
            A += t * C;
            B += t * D;
        }
    }

    // Fall back to infinity focus if the system has no optical power
    if (abs(C) < 1e-10)
        return -A / C;

    float f = -1.0 / C;
    float bfd = -A / C;
    float rpp = (1.0 - A) / C;
    float fpp = (D - 1.0) / C;

    if (focus_mm <= 0.0)
        return bfd;

    float d_o = focus_mm - total_length + fpp;
    if (d_o <= f)
        return bfd;

    float d_i = f * d_o / (d_o - f);
    return rpp + d_i;
}

void compute_exit_pupil(
    int num_surfaces,
    float radii[MAX_SURFACES],
    float thicknesses[MAX_SURFACES],
    float iors[MAX_SURFACES],
    int surface_types[MAX_SURFACES],
    output float ep_z_x, output float ep_mag_x,
    output float ep_z_y, output float ep_mag_y)
{
    int stop_index = 0;
    for (int i = 0; i < num_surfaces; i++) {
        if (surface_types[i] == SURFACE_STOP) { stop_index = i; break; }
    }

    // Build dual ABCD matrices for the rear subsystem (stop -> rear vertex).
    // Separate X and Y axes to handle cylindrical surfaces correctly.
    float Ax = 1.0, Bx = 0.0, Cx = 0.0, Dx = 1.0;
    float Ay = 1.0, By = 0.0, Cy = 0.0, Dy = 1.0;

    // Initial transfer from stop to first rear surface
    float t = thicknesses[stop_index] / iors[stop_index];
    Ax += t * Cx;  Bx += t * Dx;
    Ay += t * Cy;  By += t * Dy;

    for (int i = stop_index + 1; i < num_surfaces; i++) {
        float n_before = iors[i - 1];
        float n_after = iors[i];

        if (is_curved_surface(surface_types[i]) && n_before != n_after) {
            float phi = (n_after - n_before) / radii[i];
            // Spherical/aspheric: power in both axes
            // Cylindrical_x: power in X only
            // Cylindrical_y: power in Y only
            if (surface_types[i] != SURFACE_CYLINDRICAL_Y) {
                Cx -= phi * Ax;
                Dx -= phi * Bx;
            }
            if (surface_types[i] != SURFACE_CYLINDRICAL_X) {
                Cy -= phi * Ay;
                Dy -= phi * By;
            }
        }

        if (i < num_surfaces - 1) {
            t = thicknesses[i] / iors[i];
            Ax += t * Cx;  Bx += t * Dx;
            Ay += t * Cy;  By += t * Dy;
        }
    }

    if (abs(Dx) < 1e-10) {
        ep_z_x = 0.0;
        ep_mag_x = 0.0;
    } else {
        ep_z_x = -Bx / Dx;
        ep_mag_x = abs(1.0 / Dx);
    }

    if (abs(Dy) < 1e-10) {
        ep_z_y = 0.0;
        ep_mag_y = 0.0;
    } else {
        ep_z_y = -By / Dy;
        ep_mag_y = abs(1.0 / Dy);
    }
}

void compute_field_exit_pupil(
    float sensor_x, float sensor_y, float sensor_z,
    float ep_z, float stop_z, float aim_semi_ap,
    int num_surfaces,
    int surface_types[MAX_SURFACES],
    float thicknesses[MAX_SURFACES],
    float apertures[MAX_SURFACES],
    output float ep_cx, output float ep_cy, output float ep_r)
{
    int stop_index = 0;
    for (int i = 0; i < num_surfaces; i++) {
        if (surface_types[i] == SURFACE_STOP) { stop_index = i; break; }
    }

    // Chief ray crossing: where a ray from the sensor through the stop center
    // hits the exit pupil plane
    float chief_t = (ep_z - sensor_z) / (stop_z - sensor_z);
    ep_cx = sensor_x * (1.0 - chief_t);
    ep_cy = sensor_y * (1.0 - chief_t);
    ep_r = aim_semi_ap;

    // Accumulate z from stop to each rear surface
    float vz = stop_z;
    for (int i = stop_index + 1; i < num_surfaces; i++) {
        vz += thicknesses[i - 1];
        float semi_ap = apertures[i] * 0.5;

        float t_i = (vz - sensor_z) / (ep_z - sensor_z);
        if (abs(t_i) < 1e-10)
            continue;

        // Constraint circle: projection of surface i's aperture onto the EP plane
        float inv_t = 1.0 / t_i;
        float cc_x = -sensor_x * (1.0 - t_i) * inv_t;
        float cc_y = -sensor_y * (1.0 - t_i) * inv_t;
        float cc_r = semi_ap * abs(inv_t);

        // Largest disk centered at (ep_cx, ep_cy) fitting inside this constraint
        float dx = ep_cx - cc_x;
        float dy = ep_cy - cc_y;
        float dist = sqrt(dx * dx + dy * dy);
        float max_r = cc_r - dist;

        if (max_r < ep_r)
            ep_r = max_r;
    }

    // Safety margin: straight-line projection doesn't account for refraction
    ep_r *= 1.1;
    if (ep_r > aim_semi_ap)
        ep_r = aim_semi_ap;
    if (ep_r < 0.0)
        ep_r = 0.0;
}

// Per-pair ABCD trace through the full ghost path (all three phases including
// reflections) to find the tightest aperture constraint projected back to the
// aim plane. Returns a ghost-specific aim radius that replaces the main exit
// pupil radius for ghost ray sampling.
float compute_ghost_aim_radius(
    int bounce_a, int bounce_b,
    int num_surfaces,
    float radii[MAX_SURFACES],
    float iors[MAX_SURFACES],
    float apertures[MAX_SURFACES],
    int surface_types[MAX_SURFACES],
    float vertex_z[MAX_SURFACES],
    float aperture_scale,
    float sensor_z, float aim_z, float aim_semi_ap,
    output float out_Cx, output float out_Dx,
    output float out_Cy, output float out_Dy)
{
    float Ax = 1.0, Bx = 0.0, Cx = 0.0, Dx = 1.0;
    float Ay = 1.0, By = 0.0, Cy = 0.0, Dy = 1.0;

    float prev_z = aim_z;
    float cur_n = iors[num_surfaces - 1];
    float result = aim_semi_ap;
    float inv_sensor_aim = 1.0 / (sensor_z - aim_z);

    // Phase 1: aim plane → bounce_a (step -1, reflect at bounce_a)
    for (int i = num_surfaces - 1; i >= bounce_a; i--) {
        // Transfer from prev_z to vertex_z[i]
        float dist = vertex_z[i] - prev_z;
        float t = dist / cur_n;
        Ax += t * Cx;  Bx += t * Dx;
        Ay += t * Cy;  By += t * Dy;

        // Aperture constraint at this surface
        float semi_ap = apertures[i] * 0.5;
        if (surface_types[i] == SURFACE_STOP)
            semi_ap *= aperture_scale;
        float Meff_x = abs(Ax - Bx * inv_sensor_aim);
        float Meff_y = abs(Ay - By * inv_sensor_aim);
        float Meff = max(Meff_x, Meff_y);
        if (Meff > 1e-10) {
            float constraint = semi_ap / Meff;
            if (constraint < result)
                result = constraint;
        }

        // Power: refraction or reflection
        if (i == bounce_a) {
            // Reflection reverses the propagation direction, negating the
            // reduced angle u = n*dh/dz. In ABCD terms this negates C and D.
            // Curvature power is applied on top of the direction reversal.
            Cx = -Cx;  Dx = -Dx;
            Cy = -Cy;  Dy = -Dy;
            if (is_curved_surface(surface_types[i]) && radii[i] != 0.0) {
                float phi = 2.0 * cur_n / radii[i];
                if (surface_types[i] != SURFACE_CYLINDRICAL_Y) {
                    Cx -= phi * Ax;  Dx -= phi * Bx;
                }
                if (surface_types[i] != SURFACE_CYLINDRICAL_X) {
                    Cy -= phi * Ay;  Dy -= phi * By;
                }
            }
        } else if (surface_types[i] != SURFACE_STOP) {
            // Refraction (step -1): n_after = iors[i-1] or 1.0
            float n_after = (i > 0) ? iors[i - 1] : 1.0;
            if (is_curved_surface(surface_types[i]) && cur_n != n_after) {
                float phi = (n_after - cur_n) / radii[i];
                if (surface_types[i] != SURFACE_CYLINDRICAL_Y) {
                    Cx -= phi * Ax;  Dx -= phi * Bx;
                }
                if (surface_types[i] != SURFACE_CYLINDRICAL_X) {
                    Cy -= phi * Ay;  Dy -= phi * By;
                }
            }
            cur_n = n_after;
        }

        prev_z = vertex_z[i];
    }

    // Phase 2: bounce_a+1 → bounce_b (step +1, reflect at bounce_b)
    for (int i = bounce_a + 1; i <= bounce_b; i++) {
        float dist = vertex_z[i] - prev_z;
        float t = dist / cur_n;
        Ax += t * Cx;  Bx += t * Dx;
        Ay += t * Cy;  By += t * Dy;

        float semi_ap = apertures[i] * 0.5;
        if (surface_types[i] == SURFACE_STOP)
            semi_ap *= aperture_scale;
        float Meff_x = abs(Ax - Bx * inv_sensor_aim);
        float Meff_y = abs(Ay - By * inv_sensor_aim);
        float Meff = max(Meff_x, Meff_y);
        if (Meff > 1e-10) {
            float constraint = semi_ap / Meff;
            if (constraint < result)
                result = constraint;
        }

        if (i == bounce_b) {
            Cx = -Cx;  Dx = -Dx;
            Cy = -Cy;  Dy = -Dy;
            if (is_curved_surface(surface_types[i]) && radii[i] != 0.0) {
                float phi = 2.0 * cur_n / radii[i];
                if (surface_types[i] != SURFACE_CYLINDRICAL_Y) {
                    Cx -= phi * Ax;  Dx -= phi * Bx;
                }
                if (surface_types[i] != SURFACE_CYLINDRICAL_X) {
                    Cy -= phi * Ay;  Dy -= phi * By;
                }
            }
        } else if (surface_types[i] != SURFACE_STOP) {
            // Refraction (step +1): n_after = iors[i]
            float n_after = iors[i];
            if (is_curved_surface(surface_types[i]) && cur_n != n_after) {
                float phi = (n_after - cur_n) / radii[i];
                if (surface_types[i] != SURFACE_CYLINDRICAL_Y) {
                    Cx -= phi * Ax;  Dx -= phi * Bx;
                }
                if (surface_types[i] != SURFACE_CYLINDRICAL_X) {
                    Cy -= phi * Ay;  Dy -= phi * By;
                }
            }
            cur_n = n_after;
        }

        prev_z = vertex_z[i];
    }

    // Phase 3: bounce_b-1 → 0 (step -1, refraction only)
    for (int i = bounce_b - 1; i >= 0; i--) {
        float dist = vertex_z[i] - prev_z;
        float t = dist / cur_n;
        Ax += t * Cx;  Bx += t * Dx;
        Ay += t * Cy;  By += t * Dy;

        float semi_ap = apertures[i] * 0.5;
        if (surface_types[i] == SURFACE_STOP)
            semi_ap *= aperture_scale;
        float Meff_x = abs(Ax - Bx * inv_sensor_aim);
        float Meff_y = abs(Ay - By * inv_sensor_aim);
        float Meff = max(Meff_x, Meff_y);
        if (Meff > 1e-10) {
            float constraint = semi_ap / Meff;
            if (constraint < result)
                result = constraint;
        }

        if (surface_types[i] != SURFACE_STOP) {
            float n_after = (i > 0) ? iors[i - 1] : 1.0;
            if (is_curved_surface(surface_types[i]) && cur_n != n_after) {
                float phi = (n_after - cur_n) / radii[i];
                if (surface_types[i] != SURFACE_CYLINDRICAL_Y) {
                    Cx -= phi * Ax;  Dx -= phi * Bx;
                }
                if (surface_types[i] != SURFACE_CYLINDRICAL_X) {
                    Cy -= phi * Ay;  Dy -= phi * By;
                }
            }
            cur_n = n_after;
        }

        prev_z = vertex_z[i];
    }

    out_Cx = Cx;  out_Dx = Dx;
    out_Cy = Cy;  out_Dy = Dy;
    return max(result, 0.0);
}

int intersect_sphere(
    point ray_origin,
    vector ray_dir,
    float sphere_center_z,
    float radius,
    output point hit_point)
{
    float ox = ray_origin[0];
    float oy = ray_origin[1];
    float oz = ray_origin[2] - sphere_center_z;
    float dx = ray_dir[0];
    float dy = ray_dir[1];
    float dz = ray_dir[2];

    float a = dx * dx + dy * dy + dz * dz;
    float b = 2.0 * (ox * dx + oy * dy + oz * dz);
    float c = ox * ox + oy * oy + oz * oz - radius * radius;

    float disc = b * b - 4.0 * a * c;
    if (disc < 0.0)
        return 0;

    float sqrt_disc = sqrt(disc);
    float t1 = (-b - sqrt_disc) / (2.0 * a);
    float t2 = (-b + sqrt_disc) / (2.0 * a);

    // Pick the intersection closest to the vertex (sphere_center_z - radius).
    // Do NOT fall back to the far-side intersection — if the vertex-side hit
    // is behind the ray, the ray has passed this surface and should be rejected.
    float vertex_z = sphere_center_z - radius;
    point p1 = ray_origin + t1 * ray_dir;
    point p2 = ray_origin + t2 * ray_dir;

    float dist1 = abs(p1[2] - vertex_z);
    float dist2 = abs(p2[2] - vertex_z);

    if (dist1 < dist2) {
        if (t1 > 1e-6) {
            hit_point = p1;
            return 1;
        }
    } else {
        if (t2 > 1e-6) {
            hit_point = p2;
            return 1;
        }
    }

    return 0;
}

int intersect_cylindrical(
    point ray_origin,
    vector ray_dir,
    float sphere_center_z,
    float radius,
    int surface_type,
    output point hit_point)
{
    // Cylindrical surface: circle in one axis + z, infinite in the other.
    // SURFACE_CYLINDRICAL_X: curvature in X-Z plane (flat in Y)
    // SURFACE_CYLINDRICAL_Y: curvature in Y-Z plane (flat in X)
    float oz = ray_origin[2] - sphere_center_z;
    float dz = ray_dir[2];

    float oh, dh;
    if (surface_type == SURFACE_CYLINDRICAL_X) {
        oh = ray_origin[0];
        dh = ray_dir[0];
    } else {
        oh = ray_origin[1];
        dh = ray_dir[1];
    }

    float a = dh * dh + dz * dz;
    float b = 2.0 * (oh * dh + oz * dz);
    float c = oh * oh + oz * oz - radius * radius;

    float disc = b * b - 4.0 * a * c;
    if (disc < 0.0)
        return 0;

    float sqrt_disc = sqrt(disc);
    float t1 = (-b - sqrt_disc) / (2.0 * a);
    float t2 = (-b + sqrt_disc) / (2.0 * a);

    float vertex_z = sphere_center_z - radius;
    point p1 = ray_origin + t1 * ray_dir;
    point p2 = ray_origin + t2 * ray_dir;

    float dist1 = abs(p1[2] - vertex_z);
    float dist2 = abs(p2[2] - vertex_z);

    if (dist1 < dist2) {
        if (t1 > 1e-6) {
            hit_point = p1;
            return 1;
        }
    } else {
        if (t2 > 1e-6) {
            hit_point = p2;
            return 1;
        }
    }

    return 0;
}

float aspheric_sag(float h, float c, float k, float A4, float A6, float A8, float A10) {
    float h2 = h * h;
    float Q = max(1.0 - (1.0 + k) * c * c * h2, 1e-20);
    float sag = c * h2 / (1.0 + sqrt(Q)) + A4 * h2 * h2 + A6 * h2 * h2 * h2
                + A8 * h2 * h2 * h2 * h2 + A10 * h2 * h2 * h2 * h2 * h2;
    return sag;
}

float aspheric_sag_prime(float h, float c, float k, float A4, float A6, float A8, float A10) {
    float h2 = h * h;
    float Q = max(1.0 - (1.0 + k) * c * c * h2, 1e-20);
    return c * h / sqrt(Q) + 4.0 * A4 * h * h2 + 6.0 * A6 * h * h2 * h2
           + 8.0 * A8 * h * h2 * h2 * h2 + 10.0 * A10 * h * h2 * h2 * h2 * h2;
}

int intersect_aspheric(
    point ray_origin, vector ray_dir,
    float vertex_z, float radius,
    float k, float A4, float A6, float A8, float A10,
    output point hit_point)
{
    // Seed with spherical intersection
    point sphere_hit = point(0, 0, 0);
    float sphere_center_z = vertex_z + radius;
    if (!intersect_sphere(ray_origin, ray_dir, sphere_center_z, radius, sphere_hit))
        return 0;

    float c = 1.0 / radius;
    float ox = ray_origin[0], oy = ray_origin[1], oz = ray_origin[2];
    float dx = ray_dir[0], dy = ray_dir[1], dz = ray_dir[2];

    // Initial t from sphere seed
    float t = (abs(dx) > abs(dy))
        ? (sphere_hit[0] - ox) / dx
        : (abs(dy) > 1e-10 ? (sphere_hit[1] - oy) / dy : (sphere_hit[2] - oz) / dz);

    // Newton-Raphson refinement
    float F = 0.0;
    for (int iter = 0; iter < 10; iter++) {
        float px = ox + t * dx;
        float py = oy + t * dy;
        float pz = oz + t * dz;
        float h = sqrt(px * px + py * py);
        float s = aspheric_sag(h, c, k, A4, A6, A8, A10);
        F = pz - vertex_z - s;
        if (abs(F) < 1e-8)
            break;
        float sp = aspheric_sag_prime(h, c, k, A4, A6, A8, A10);
        float dh_dt = (h > 1e-10) ? (px * dx + py * dy) / h : 0.0;
        float dF_dt = dz - sp * dh_dt;
        if (abs(dF_dt) < 1e-20)
            break;
        t -= F / dF_dt;
    }

    if (t < 1e-6 || abs(F) > 1e-4)
        return 0;

    hit_point = point(ox + t * dx, oy + t * dy, oz + t * dz);
    return 1;
}

// Geometry helper: find intersection point and surface normal for any surface type.
// Returns: 1=hit, 0=miss, -1=clipped
int find_surface_intersection(
    point ray_origin,
    vector ray_dir,
    float vertex_z,
    float radius,
    float semi_aperture,
    int surface_type,
    int num_blades,
    float blade_rotation,
    float k, float A4, float A6, float A8, float A10,
    output point hit_point,
    output vector surface_normal)
{
    if (!is_curved_surface(surface_type)) {
        float dz = ray_dir[2];
        if (abs(dz) < 1e-10)
            return 0;
        float t = (vertex_z - ray_origin[2]) / dz;
        if (t < 1e-6)
            return 0;
        hit_point = ray_origin + t * ray_dir;

        if (surface_type == SURFACE_STOP) {
            if (num_blades >= 3) {
                if (!point_in_ngon(hit_point[0], hit_point[1], semi_aperture, num_blades, blade_rotation))
                    return -1;
            } else {
                float r = sqrt(hit_point[0] * hit_point[0] + hit_point[1] * hit_point[1]);
                if (r > semi_aperture)
                    return -1;
            }
        } else {
            float r = sqrt(hit_point[0] * hit_point[0] + hit_point[1] * hit_point[1]);
            if (r > semi_aperture)
                return -1;
        }

        surface_normal = vector(0, 0, -1);
        return 1;
    }

    point hit = point(0, 0, 0);

    if (surface_type == SURFACE_ASPHERIC) {
        if (!intersect_aspheric(ray_origin, ray_dir, vertex_z, radius, k, A4, A6, A8, A10, hit))
            return 0;
    } else if (surface_type == SURFACE_CYLINDRICAL_X || surface_type == SURFACE_CYLINDRICAL_Y) {
        float cyl_center_z = vertex_z + radius;
        if (!intersect_cylindrical(ray_origin, ray_dir, cyl_center_z, radius, surface_type, hit))
            return 0;
    } else {
        float sphere_center_z = vertex_z + radius;
        if (!intersect_sphere(ray_origin, ray_dir, sphere_center_z, radius, hit))
            return 0;
    }

    float r = sqrt(hit[0] * hit[0] + hit[1] * hit[1]);
    if (r > semi_aperture)
        return -1;

    vector N;
    if (surface_type == SURFACE_ASPHERIC) {
        float c = 1.0 / radius;
        float h = sqrt(hit[0] * hit[0] + hit[1] * hit[1]);
        if (h > 1e-10) {
            float sp = aspheric_sag_prime(h, c, k, A4, A6, A8, A10);
            N = normalize(vector(-sp * hit[0] / h, -sp * hit[1] / h, 1.0));
        } else {
            N = vector(0, 0, 1);
        }
    } else if (surface_type == SURFACE_CYLINDRICAL_X) {
        float cyl_center_z = vertex_z + radius;
        N = normalize(vector(hit[0], 0, hit[2] - cyl_center_z));
    } else if (surface_type == SURFACE_CYLINDRICAL_Y) {
        float cyl_center_z = vertex_z + radius;
        N = normalize(vector(0, hit[1], hit[2] - cyl_center_z));
    } else {
        float sphere_center_z = vertex_z + radius;
        N = normalize(hit - point(0, 0, sphere_center_z));
    }

    hit_point = hit;
    surface_normal = N;
    return 1;
}

// Returns: 1 = success, 0 = intersection miss, -1 = aperture clip, -2 = TIR
int refract_at_surface(
    point ray_origin,
    vector ray_dir,
    float vertex_z,
    float radius,
    float semi_aperture,
    float n1,
    float n2,
    int num_blades,
    float blade_rotation,
    int surface_type,
    float lambda_nm,
    float coating,
    float k, float A4, float A6, float A8, float A10,
    output point new_origin,
    output vector new_dir,
    output float transmission)
{
    point hit = point(0, 0, 0);
    vector N = vector(0, 0, 0);
    int result = find_surface_intersection(
        ray_origin, ray_dir, vertex_z, radius, semi_aperture,
        surface_type, num_blades, blade_rotation,
        k, A4, A6, A8, A10, hit, N);

    if (result != 1)
        return result;

    new_origin = hit;

    if (surface_type == SURFACE_STOP) {
        new_dir = ray_dir;
        transmission = 1.0;
        return 1;
    }

    if (n1 == n2) {
        new_dir = ray_dir;
        transmission = 1.0;
        return 1;
    }

    vector I = normalize(ray_dir);
    if (dot(I, N) > 0.0)
        N = -N;

    float cos_i = abs(dot(I, N));
    vector refracted = refract(I, N, n1 / n2);
    if (dot(refracted, refracted) < 1e-10)
        return -2;

    float cos_t = abs(dot(refracted, N));
    transmission = fresnel_transmittance(n1, n2, cos_i, cos_t, lambda_nm, coating);
    new_dir = refracted;
    return 1;
}

// Returns: 1 = success, 0 = miss, -1 = clipped
int reflect_at_surface(
    point ray_origin,
    vector ray_dir,
    float vertex_z,
    float radius,
    float semi_aperture,
    float n1,
    float n2,
    int surface_type,
    float lambda_nm,
    float coating,
    float k, float A4, float A6, float A8, float A10,
    output point new_origin,
    output vector new_dir,
    output float reflectance)
{
    point hit = point(0, 0, 0);
    vector N = vector(0, 0, 0);
    int result = find_surface_intersection(
        ray_origin, ray_dir, vertex_z, radius, semi_aperture,
        surface_type, 0, 0.0,
        k, A4, A6, A8, A10, hit, N);

    if (result != 1)
        return result;

    vector I = normalize(ray_dir);
    if (dot(I, N) > 0.0)
        N = -N;

    float cos_i = abs(dot(I, N));
    new_origin = hit;
    new_dir = reflect(I, N);

    if (n1 == n2) {
        reflectance = 0.0;
        return 1;
    }

    float sin_t2 = (n1 * n1) / (n2 * n2) * (1.0 - cos_i * cos_i);
    float cos_t = (sin_t2 < 1.0) ? sqrt(1.0 - sin_t2) : 0.0;
    float T = fresnel_transmittance(n1, n2, cos_i, cos_t, lambda_nm, coating);
    // Cap reflectance to suppress near-TIR fireflies in ghost paths
    reflectance = min(1.0 - T, 0.25);
    return 1;
}

// failure_type output: 0 = success, 1 = intersection miss, 2 = aperture clip, 3 = TIR
int trace_lens_system(
    point ray_origin,
    vector ray_dir,
    float aperture_scale,
    int num_surfaces,
    float radii[MAX_SURFACES],
    float thicknesses[MAX_SURFACES],
    float iors[MAX_SURFACES],
    float apertures[MAX_SURFACES],
    float abbe_v[MAX_SURFACES],
    int surface_types[MAX_SURFACES],
    float extra[MAX_EXTRA],
    float lambda_nm,
    int num_blades,
    float blade_rotation,
    float coating,
    output point exit_origin,
    output vector exit_dir,
    output int surfaces_passed,
    output int failure_type,
    output float total_transmission)
{
    surfaces_passed = 0;
    failure_type = 0;
    total_transmission = 1.0;

    // Compute vertex z-positions (PBRT convention: front at most negative z,
    // rear at z=0). This ensures sphere curvature pushes off-axis hits away
    // from subsequent surfaces, preventing overshoot at thin air gaps.
    float vertex_z[MAX_SURFACES];
    float total_length = 0.0;
    for (int i = 0; i < num_surfaces - 1; i++)
        total_length += thicknesses[i];

    vertex_z[0] = -total_length;
    for (int i = 1; i < num_surfaces; i++)
        vertex_z[i] = vertex_z[i - 1] + thicknesses[i - 1];

    point  p = ray_origin;
    vector d = ray_dir;

    // State saved before flat surfaces for sphere-overlap retry.
    // When a curved surface's sphere extends past an adjacent flat surface,
    // we may need to roll back and reprocess. Two cases:
    //   Overshoot: curved hit overshoots past the next flat — handle flat early
    //   Mirror: flat processed first but curved sphere is unreachable — retry
    point saved_p = point(0, 0, 0);
    vector saved_d = vector(0, 0, 0);
    float saved_transmission = 0.0;
    int saved_surfaces = 0;
    int saved_idx = -1;

    // Trace rear-to-front: last surface down to surface 0
    int skip_count = 0;
    for (int idx = num_surfaces - 1; idx >= 0; idx--) {
        if (skip_count > 0) {
            skip_count -= 1;
            saved_idx = -1;
            continue;
        }

        // Save ray state before flat surfaces for sphere-overlap retry
        if (!is_curved_surface(surface_types[idx])) {
            saved_p = p;
            saved_d = d;
            saved_transmission = total_transmission;
            saved_surfaces = surfaces_passed;
            saved_idx = idx;
        }

        float semi_ap = apertures[idx] * 0.5;

        if (surface_types[idx] == SURFACE_STOP)
            semi_ap *= aperture_scale;

        // iors[i] = IOR of the medium between surface i and surface i+1
        // (toward sensor). When tracing sensor→scene at surface idx:
        // n1 = medium the ray is in (sensor side) = iors[idx]
        // n2 = medium the ray enters (scene side) = iors[idx-1] or air
        float n1 = cauchy_ior(iors[idx], abbe_v[idx], lambda_nm);
        float n2 = (idx > 0) ? cauchy_ior(iors[idx - 1], abbe_v[idx - 1], lambda_nm) : 1.0;

        if (surface_types[idx] == SURFACE_STOP) {
            n1 = 1.0;
            n2 = 1.0;
        }

        int base = idx * N_EXTRA;
        float k_i = extra[base], A4_i = extra[base + 1], A6_i = extra[base + 2], A8_i = extra[base + 3], A10_i = extra[base + 4];

        point  new_p = point(0, 0, 0);
        vector new_d = vector(0, 0, 0);
        float surface_transmission = 1.0;

        int result = refract_at_surface(p, d, vertex_z[idx], radii[idx], semi_ap, n1, n2, num_blades, blade_rotation, surface_types[idx], lambda_nm, coating, k_i, A4_i, A6_i, A8_i, A10_i, new_p, new_d, surface_transmission);

        // Mirror case: a flat surface was processed but the adjacent curved
        // surface's sphere extends past it, making intersection unreachable.
        // Roll back to before the flat surface and retry the curved one first.
        if (result != 1 && is_curved_surface(surface_types[idx]) && saved_idx == idx + 1) {
            p = saved_p;
            d = saved_d;
            total_transmission = saved_transmission;
            surfaces_passed = saved_surfaces;
            saved_idx = -1;

            result = refract_at_surface(p, d, vertex_z[idx], radii[idx], semi_ap, n1, n2, num_blades, blade_rotation, surface_types[idx], lambda_nm, coating, k_i, A4_i, A6_i, A8_i, A10_i, new_p, new_d, surface_transmission);
            if (result != 1) {
                if (result == 0) failure_type = 1;
                else if (result == -1) failure_type = 2;
                else if (result == -2) failure_type = 3;
                return 0;
            }

            surfaces_passed += 1;
            total_transmission *= surface_transmission;
            p = new_p;
            d = new_d;

            // Now handle the flat surface we rolled back
            int flat_idx = idx + 1;
            float flat_semi_ap = apertures[flat_idx] * 0.5;
            if (surface_types[flat_idx] == SURFACE_STOP)
                flat_semi_ap *= aperture_scale;

            point flat_p;
            int flat_check = check_aperture_at_plane(p, d, vertex_z[flat_idx], flat_semi_ap,
                                                     surface_types[flat_idx], num_blades, blade_rotation, flat_p);
            if (flat_check != 1) {
                failure_type = (flat_check == 0) ? 1 : 2;
                return 0;
            }
            p = flat_p;

            if (surface_types[flat_idx] != SURFACE_STOP) {
                float fn1 = cauchy_ior(iors[flat_idx], abbe_v[flat_idx], lambda_nm);
                float fn2 = (flat_idx > 0) ? cauchy_ior(iors[flat_idx - 1], abbe_v[flat_idx - 1], lambda_nm) : 1.0;
                vector flat_d; float flat_trans;
                if (!refract_at_flat_plane(d, fn1, fn2, lambda_nm, coating, flat_d, flat_trans)) {
                    failure_type = 3;
                    return 0;
                }
                total_transmission *= flat_trans;
                d = flat_d;
            }

            surfaces_passed += 1;
            continue;
        }

        if (result != 1) {
            if (result == 0) failure_type = 1;
            else if (result == -1) failure_type = 2;
            else if (result == -2) failure_type = 3;
            return 0;
        }

        surfaces_passed += 1;
        total_transmission *= surface_transmission;
        p = new_p;
        d = new_d;

        if (is_curved_surface(surface_types[idx]))
            saved_idx = -1;

        // Overshoot: a curved surface hit overshoots past the next flat
        // surface's vertex. Handle the flat surface now and skip it later.
        if (idx > 0 && !is_curved_surface(surface_types[idx - 1]) && p[2] < vertex_z[idx - 1]) {
            int next_idx = idx - 1;
            float next_semi_ap = apertures[next_idx] * 0.5;
            if (surface_types[next_idx] == SURFACE_STOP)
                next_semi_ap *= aperture_scale;

            point next_p;
            int next_check = check_aperture_at_plane(p, d, vertex_z[next_idx], next_semi_ap,
                                                     surface_types[next_idx], num_blades, blade_rotation, next_p);
            if (next_check != 1) {
                failure_type = (next_check == 0) ? 1 : 2;
                return 0;
            }
            p = next_p;

            if (surface_types[next_idx] != SURFACE_STOP) {
                float fn1 = cauchy_ior(iors[next_idx], abbe_v[next_idx], lambda_nm);
                float fn2 = (next_idx > 0) ? cauchy_ior(iors[next_idx - 1], abbe_v[next_idx - 1], lambda_nm) : 1.0;
                vector next_d; float next_trans;
                if (!refract_at_flat_plane(d, fn1, fn2, lambda_nm, coating, next_d, next_trans)) {
                    failure_type = 3;
                    return 0;
                }
                total_transmission *= next_trans;
                d = next_d;
            }

            surfaces_passed += 1;
            skip_count = 1;
        }
    }

    exit_origin = p;
    exit_dir = d;
    return 1;
}

// Trace a contiguous range of surfaces [start_idx..end_idx] in the given direction.
// Refracts at each surface except reflect_at_idx where it reflects instead.
int trace_surface_range(
    int start_idx, int end_idx, int step, int reflect_at_idx,
    point p_in, vector d_in,
    float aperture_scale,
    int num_surfaces,
    float radii[MAX_SURFACES],
    float iors[MAX_SURFACES],
    float apertures[MAX_SURFACES],
    float abbe_v[MAX_SURFACES],
    int surface_types[MAX_SURFACES],
    float extra[MAX_EXTRA],
    float vertex_z[MAX_SURFACES],
    float lambda_nm,
    int num_blades,
    float blade_rotation,
    float coating,
    output point p_out,
    output vector d_out,
    output float total_transmission)
{
    p_out = p_in;
    d_out = d_in;
    total_transmission = 1.0;

    for (int idx = start_idx; ; idx += step) {
        float semi_ap = apertures[idx] * 0.5;
        if (surface_types[idx] == SURFACE_STOP)
            semi_ap *= aperture_scale;

        float n1, n2;
        if (step < 0) {
            n1 = cauchy_ior(iors[idx], abbe_v[idx], lambda_nm);
            n2 = (idx > 0) ? cauchy_ior(iors[idx - 1], abbe_v[idx - 1], lambda_nm) : 1.0;
        } else {
            n1 = (idx > 0) ? cauchy_ior(iors[idx - 1], abbe_v[idx - 1], lambda_nm) : 1.0;
            n2 = cauchy_ior(iors[idx], abbe_v[idx], lambda_nm);
        }
        if (surface_types[idx] == SURFACE_STOP) {
            n1 = 1.0;
            n2 = 1.0;
        }

        int base = idx * N_EXTRA;
        float k_i = extra[base], A4_i = extra[base + 1], A6_i = extra[base + 2];
        float A8_i = extra[base + 3], A10_i = extra[base + 4];

        point new_p = point(0, 0, 0);
        vector new_d = vector(0, 0, 0);

        if (idx == reflect_at_idx) {
            float reflectance = 0.0;
            int result = reflect_at_surface(
                p_out, d_out, vertex_z[idx], radii[idx], semi_ap,
                n1, n2, surface_types[idx], lambda_nm, coating,
                k_i, A4_i, A6_i, A8_i, A10_i,
                new_p, new_d, reflectance);
            if (result != 1)
                return 0;
            total_transmission *= reflectance;
        } else {
            float trans = 1.0;
            int result = refract_at_surface(
                p_out, d_out, vertex_z[idx], radii[idx], semi_ap,
                n1, n2, num_blades, blade_rotation, surface_types[idx], lambda_nm, coating,
                k_i, A4_i, A6_i, A8_i, A10_i,
                new_p, new_d, trans);
            if (result != 1)
                return 0;
            total_transmission *= trans;
        }

        p_out = new_p;
        d_out = new_d;

        if (idx == end_idx)
            break;
    }

    return 1;
}

// Trace a ghost path with two reflections: bounce_a (front-ward) and bounce_b (rear-ward).
// bounce_a < bounce_b. The ray refracts normally except at the two bounce surfaces.
int trace_ghost_path(
    int bounce_a, int bounce_b,
    point p_in, vector d_in,
    float aperture_scale,
    int num_surfaces,
    float radii[MAX_SURFACES],
    float iors[MAX_SURFACES],
    float apertures[MAX_SURFACES],
    float abbe_v[MAX_SURFACES],
    int surface_types[MAX_SURFACES],
    float extra[MAX_EXTRA],
    float vertex_z[MAX_SURFACES],
    float lambda_nm,
    int num_blades,
    float blade_rotation,
    float coating,
    output point p_out,
    output vector d_out,
    output float total_transmission)
{
    total_transmission = 1.0;
    p_out = p_in;
    d_out = d_in;
    float phase_T = 1.0;

    // Phase 1: sensor → front, reflect at bounce_a
    if (!trace_surface_range(
            num_surfaces - 1, bounce_a, -1, bounce_a,
            p_out, d_out, aperture_scale, num_surfaces,
            radii, iors, apertures, abbe_v, surface_types, extra, vertex_z,
            lambda_nm, num_blades, blade_rotation, coating,
            p_out, d_out, phase_T))
        return 0;
    total_transmission *= phase_T;

    // Phase 2: front → rear, reflect at bounce_b
    if (!trace_surface_range(
            bounce_a + 1, bounce_b, 1, bounce_b,
            p_out, d_out, aperture_scale, num_surfaces,
            radii, iors, apertures, abbe_v, surface_types, extra, vertex_z,
            lambda_nm, num_blades, blade_rotation, coating,
            p_out, d_out, phase_T))
        return 0;
    total_transmission *= phase_T;

    // Phase 3: rear → front, normal refraction to exit
    if (bounce_b > 0) {
        if (!trace_surface_range(
                bounce_b - 1, 0, -1, -1,
                p_out, d_out, aperture_scale, num_surfaces,
                radii, iors, apertures, abbe_v, surface_types, extra, vertex_z,
                lambda_nm, num_blades, blade_rotation, coating,
                p_out, d_out, phase_T))
            return 0;
        total_transmission *= phase_T;
    }

    return 1;
}

// Aperture diffraction starburst via two-component mixture model.
// Returns a weight multiplier and sets a transverse direction perturbation.
// Core rays (most energy) pass through unperturbed; spike rays are deflected
// along edge-perpendicular directions with Cauchy-sampled sinc² weighting.
float apply_diffraction(
    int num_blades, float blade_rot_rad, float lambda_nm,
    float stop_diameter_mm, float hash1, float hash2, float hash3,
    output vector perturbation)
{
    perturbation = vector(0, 0, 0);

    if (num_blades < 3)
        return 1.0;

    int n = num_blades;
    if (stop_diameter_mm < 1e-6)
        return 1.0;
    float theta0 = (lambda_nm * 1e-6) / (stop_diameter_mm * cos(M_PI / float(n)));

    // spike_energy: fraction of PSF energy in diffraction spikes
    float spike_energy = 0.5 * (1.0 - cos(M_PI / float(n)));

    if (hash1 >= spike_energy)
        return 1.0;

    // Spike ray: select a random edge and sample along its perpendicular
    int edge = int(floor(hash2 * float(n)));
    if (edge >= n) edge = n - 1;
    float spike_angle = blade_rot_rad + (float(edge) + 0.5) * 2.0 * M_PI / float(n) + M_PI * 0.5;

    // Cauchy with scale 1/π importance-samples sinc² with near-flat weights:
    // peak weight ~1.4 at u≈0.48, vs π≈3.14 with scale 1
    float h3 = clamp(hash3, 1e-6, 1.0 - 1e-6);
    float cauchy_u = tan(M_PI * (h3 - 0.5)) / M_PI;

    float sinc_val;
    if (abs(cauchy_u) < 1e-6) {
        sinc_val = 1.0;
    } else {
        float piu = M_PI * cauchy_u;
        sinc_val = sin(piu) / piu;
        sinc_val *= sinc_val;
    }
    float weight = sinc_val * (1.0 + M_PI * M_PI * cauchy_u * cauchy_u);

    float theta = cauchy_u * theta0;
    perturbation = vector(cos(spike_angle) * theta, sin(spike_angle) * theta, 0.0);
    return weight;
}

shader lens_camera(
    float aperture_scale = 1.0
        [[ string description = "Scale factor for the aperture stop opening. 1.0 = wide open." ]],
    int lens_type = 0
        [[ string description = "Lens selection index (see add-on UI for available lenses)." ]],
    int aperture_blades = 0
        [[ string description = "Number of aperture blades. 0 = circular." ]],
    float blade_rotation = 0.0
        [[ string description = "Aperture blade rotation in degrees." ]],
    int chromatic_aberration = 1
        [[ string description = "Enable chromatic aberration (spectral dispersion)." ]],
    int lens_ghosts = 0
        [[ string description = "Enable ghost/flare simulation (double-bounce reflections)." ]],
    float ghost_intensity = 1.0
        [[ string description = "Brightness multiplier for ghost images." ]],
    int diffraction = 0
        [[ string description = "Enable aperture diffraction (starburst spikes)." ]],
    float debug_mode = 0.0
        [[ string description = "0=normal, 1=pinhole, 2=diagnostic, 3=exit dir, 4=ghosts only, 5=ghost aim" ]],
    output point position = 0,
    output vector direction = 0,
    output color throughput = 1)
{
    // Sensor size from Blender camera
    vector sensor_size = 0;
    getattribute("cam:sensor_size", sensor_size);
    float sensor_w = sensor_size[0];
    float sensor_h = sensor_size[1];

    float focal_distance = 0.0;
    getattribute("cam:focal_distance", focal_distance);

    // Raster position (0-1 range)
    point raster = camera_shader_raster_position();
    float rx = raster[0];
    float ry = raster[1];

    // Map raster coordinates to physical sensor position (mm).
    // Negate to compensate for lens inversion (real lenses flip the image).
    float sensor_x = (0.5 - rx) * sensor_w;
    float sensor_y = (0.5 - ry) * sensor_h;

    // Debug mode 1: pinhole camera to verify the framework
    // +Z is the view direction in Blender's OSL camera convention
    if (debug_mode >= 0.5 && debug_mode < 1.5) {
        position = point(0, 0, 0);
        direction = normalize(vector(-sensor_x, -sensor_y, 50.0));
        throughput = 1.0;
        return;
    }

    // Load lens data
    float radii[MAX_SURFACES];
    float thicknesses[MAX_SURFACES];
    float iors[MAX_SURFACES];
    float apertures[MAX_SURFACES];
    float abbe_v[MAX_SURFACES];
    int surface_types[MAX_SURFACES];
    float extra[MAX_EXTRA];
    float thicknesses_close[MAX_SURFACES];
    float focus_close_distance = 0.0;
    int num_surfaces = 0;
    float coating = 0.0;
    float squeeze = 1.0;
    load_lens_data(lens_type, radii, thicknesses, iors, apertures, abbe_v,
                   surface_types, extra, thicknesses_close, focus_close_distance,
                   num_surfaces, coating, squeeze);

    // Anamorphic desqueeze: narrow sensor X sampling so the lens squeeze produces correct proportions
    sensor_x /= squeeze;

    int stop_index = 0;
    for (int i = 0; i < num_surfaces; i++) {
        if (surface_types[i] == SURFACE_STOP) { stop_index = i; break; }
    }

    float focus_mm = focal_distance * 1000.0;

    // Interpolate variable thicknesses for current focus distance.
    // Uses linear interpolation in reciprocal object-distance space.
    if (focus_close_distance > 0.0 && focus_mm > 0.0) {
        float total_length_inf = 0.0;
        for (int i = 0; i < num_surfaces - 1; i++)
            total_length_inf += thicknesses[i];

        float d_obj = focus_mm - total_length_inf;
        float alpha = (d_obj > 0.0)
            ? clamp(focus_close_distance / d_obj, 0.0, 1.0)
            : 1.0;

        for (int i = 0; i < num_surfaces; i++)
            thicknesses[i] = mix(thicknesses[i], thicknesses_close[i], alpha);
    }

    float total_length = 0.0;
    for (int i = 0; i < num_surfaces - 1; i++)
        total_length += thicknesses[i];
    float sensor_distance = compute_sensor_distance(
        num_surfaces, radii, thicknesses, iors, surface_types, total_length, focus_mm);

    float vertex_z[MAX_SURFACES];
    vertex_z[0] = -total_length;
    for (int i = 1; i < num_surfaces; i++)
        vertex_z[i] = vertex_z[i - 1] + thicknesses[i - 1];

    // camera_shader_random_sample() provides two uniform values in x/y.
    // x = aperture angle (sector + barycentric u1), y = barycentric u2; the
    // actual aperture radius is derived from both barycentric coordinates.
    // Wavelength is derived from a hash of both to avoid correlation with
    // aperture position — a linear mapping would preserve the quasi-random
    // sequence structure and create systematic color-position patterns.
    point rnd = camera_shader_random_sample();

    // Wavelength sampling for chromatic aberration
    float lambda = 587.6;
    float r_param = rnd[1];
    if (chromatic_aberration) {
        float h = sin(rnd[0] * 12.9898 + rnd[1] * 78.233) * 43758.5453;
        lambda = 400.0 + (h - floor(h)) * 300.0;
    }

    // Compute wavelength-adjusted IOR for exit pupil aiming and Fresnel
    // normalization. Lenses with high dispersion shift the exit pupil at
    // extreme wavelengths; d-line-only aiming causes intersection misses.
    float dispersed_iors[MAX_SURFACES];
    for (int i = 0; i < num_surfaces; i++)
        dispersed_iors[i] = cauchy_ior(iors[i], abbe_v[i], lambda);

    float onaxis_T = onaxis_fresnel_transmission(num_surfaces, radii, dispersed_iors, lambda, coating);

    // Lens layout: rear element at z=0, front element at z=-total_length.
    // Sensor is behind the rear element at z = +sensor_distance.
    float sensor_z = sensor_distance;
    point sensor_point = point(sensor_x, sensor_y, sensor_z);

    // Compute the aperture stop's z-position
    float stop_z = -total_length;
    for (int i = 0; i < stop_index; i++)
        stop_z += thicknesses[i];

    // Sample on the exit pupil plane to reduce wasted rays for off-axis points.
    // The exit pupil is the image of the aperture stop as seen through the rear
    // lens group — it differs in position and size from the physical stop.
    // For anamorphic lenses, the exit pupil has separate X/Y magnifications.
    float stop_semi_ap = apertures[stop_index] * 0.5 * aperture_scale;

    float ep_z_x = 0.0, ep_mag_x = 1.0;
    float ep_z_y = 0.0, ep_mag_y = 1.0;
    compute_exit_pupil(num_surfaces, radii, thicknesses, dispersed_iors, surface_types,
                       ep_z_x, ep_mag_x, ep_z_y, ep_mag_y);

    // Use Y-axis exit pupil for aim position (focus axis)
    float aim_z = (ep_mag_y > 0.0) ? ep_z_y : stop_z;
    float aim_semi_ap_y = (ep_mag_y > 0.0) ? stop_semi_ap * ep_mag_y : stop_semi_ap;

    // Project X exit pupil to the aim plane by matching angular subtense.
    // For anamorphic lenses the X exit pupil can be far from the Y one
    // (even behind the sensor), so raw magnification at the wrong Z gives
    // a wildly wrong aperture size. For spherical lenses ep_z_x == ep_z_y
    // and the projection is a no-op.
    float aim_semi_ap_x = aim_semi_ap_y;
    if (ep_mag_x > 0.0) {
        float x_pupil_semi_ap = stop_semi_ap * ep_mag_x;
        float dist_to_ep_x = abs(sensor_z - ep_z_x);
        float dist_to_aim  = abs(sensor_z - aim_z);
        if (dist_to_ep_x > 1e-6)
            aim_semi_ap_x = x_pupil_semi_ap * dist_to_aim / dist_to_ep_x;
    }
    float aim_semi_ap = max(aim_semi_ap_x, aim_semi_ap_y);

    float ep_cx = 0.0, ep_cy = 0.0, field_semi_ap = aim_semi_ap;
    compute_field_exit_pupil(sensor_x, sensor_y, sensor_z,
                             aim_z, stop_z, aim_semi_ap,
                             num_surfaces, surface_types,
                             thicknesses, apertures,
                             ep_cx, ep_cy, field_semi_ap);

    if (field_semi_ap <= 0.0) {
        throughput = 0.0;
        return;
    }

    // Scale field exit pupil separately for X and Y
    float field_semi_ap_x = field_semi_ap;
    float field_semi_ap_y = field_semi_ap;
    if (aim_semi_ap > 1e-10) {
        float ratio = aim_semi_ap_x / aim_semi_ap_y;
        if (ratio > 1.0) {
            field_semi_ap_y = field_semi_ap / ratio;
        } else if (ratio < 1.0) {
            field_semi_ap_x = field_semi_ap * ratio;
        }
    }

    float blade_rot_rad = blade_rotation * M_PI / 180.0;
    float ax = 0.0;
    float ay = 0.0;

    // Ngon barycentric sampling with separate X/Y scale factors for
    // elliptical exit pupil (anamorphic lenses). For spherical lenses,
    // field_semi_ap_x == field_semi_ap_y — identical behavior.
    // For circular aperture (blades=0), use 128-gon as a proxy.
    {
        int n = (aperture_blades >= 3) ? aperture_blades : 128;
        float sector_angle = 2.0 * M_PI / float(n);
        int sector = int(floor(rnd[0] * float(n)));
        if (sector >= n) sector = n - 1;
        float u1 = rnd[0] * float(n) - float(sector);
        float u2 = r_param;
        if (u1 + u2 > 1.0) {
            u1 = 1.0 - u1;
            u2 = 1.0 - u2;
        }
        float a0 = blade_rot_rad + float(sector) * sector_angle;
        float a1 = blade_rot_rad + float(sector + 1) * sector_angle;
        ax = u1 * field_semi_ap_x * cos(a0) + u2 * field_semi_ap_x * cos(a1);
        ay = u1 * field_semi_ap_y * sin(a0) + u2 * field_semi_ap_y * sin(a1);
    }

    ax += ep_cx;
    ay += ep_cy;

    point aperture_point = point(ax, ay, aim_z);

    // Initial ray: sensor toward the stop
    vector initial_dir = normalize(aperture_point - sensor_point);

    // Ghost path handling: importance-sample pairs by normal-incidence R²
    int trace_ghost = 0;
    int num_ghost_pairs = 0;
    int ghost_a = -1, ghost_b = -1;
    float ghost_pair_weight = 0.0;
    float ghost_total_weight = 0.0;
    float adaptive_frac = 0.0;

    if (lens_ghosts) {
        // Normal-incidence Fresnel reflectance per surface (with coating)
        float surface_R[MAX_SURFACES];
        for (int i = 0; i < num_surfaces; i++) {
            surface_R[i] = 0.0;
            if (surface_types[i] == SURFACE_STOP) continue;
            float n_sensor = dispersed_iors[i];
            float n_scene = (i > 0) ? dispersed_iors[i - 1] : 1.0;
            if (n_sensor == n_scene) continue;
            surface_R[i] = coated_reflectance(n_sensor, n_scene, 1.0, 1.0, lambda, coating);
        }

        // Sum pair weights (R_a * R_b) for importance sampling CDF
        for (int a = 0; a < num_surfaces; a++) {
            if (surface_R[a] < 1e-10) continue;
            for (int b = a + 1; b < num_surfaces; b++) {
                if (surface_R[b] < 1e-10) continue;
                ghost_total_weight += surface_R[a] * surface_R[b];
                num_ghost_pairs++;
            }
        }

        if (num_ghost_pairs > 0 && ghost_total_weight > 0.0) {
            // Adaptive sample allocation: spend more on bright ghosts (uncoated),
            // less on dim ghosts (multicoated). sqrt() tames the quadratic growth
            // of total_weight with surface count.
            adaptive_frac = clamp(
                sqrt(ghost_total_weight) * ghost_intensity * 2.0,
                0.02, 0.5);

            float ghost_hash = sin(rnd[0] * 45.233 + rnd[1] * 97.113) * 21453.1211;
            ghost_hash = ghost_hash - floor(ghost_hash);
            int ghosts_only = (debug_mode >= 3.5 && debug_mode < 4.5) ? 1 : 0;

            if (ghosts_only || ghost_hash < adaptive_frac) {
                trace_ghost = 1;

                // Select pair with probability proportional to R_a * R_b
                float pair_hash = sin(rnd[0] * 31.7 + rnd[1] * 53.9) * 17431.7;
                pair_hash = pair_hash - floor(pair_hash);
                float target_w = pair_hash * ghost_total_weight;
                float cumulative = 0.0;

                for (int a = 0; a < num_surfaces && ghost_a < 0; a++) {
                    if (surface_R[a] < 1e-10) continue;
                    for (int b = a + 1; b < num_surfaces && ghost_a < 0; b++) {
                        if (surface_R[b] < 1e-10) continue;
                        cumulative += surface_R[a] * surface_R[b];
                        if (cumulative >= target_w) {
                            ghost_a = a;
                            ghost_b = b;
                            ghost_pair_weight = surface_R[a] * surface_R[b];
                        }
                    }
                }

                if (ghost_a < 0)
                    trace_ghost = 0;
            }
        }
    }

    // Debug mode 4: ghosts only — kill direct rays
    if (debug_mode >= 3.5 && debug_mode < 4.5 && !trace_ghost) {
        throughput = 0.0;
        return;
    }

    // Debug mode 5: ghost aim diagnostic
    // Flat image showing light-aiming pipeline stages.
    // R = num_lights / MAX_LIGHTS (brightness = lights found)
    // G = light aiming succeeded for this sample
    // B = ghost pair was selected (trace_ghost)
    // Black pixel = no ghost pair selected
    if (debug_mode >= 4.5 && debug_mode < 5.5) {
        position = point(0, 0, 0);
        direction = normalize(vector(-sensor_x, -sensor_y, 50.0));

        if (!trace_ghost) {
            throughput = 0.0;
            return;
        }

        // Run the same light-loading and aiming logic to see what happens
        float dbg_g_Cx = 0.0, dbg_g_Dx = 0.0, dbg_g_Cy = 0.0, dbg_g_Dy = 0.0;
        float dbg_ghost_semi_ap = compute_ghost_aim_radius(
            ghost_a, ghost_b, num_surfaces,
            radii, dispersed_iors, apertures, surface_types, vertex_z,
            aperture_scale, sensor_z, aim_z, aim_semi_ap,
            dbg_g_Cx, dbg_g_Dx, dbg_g_Cy, dbg_g_Dy);
        dbg_ghost_semi_ap *= 1.1;
        if (dbg_ghost_semi_ap > aim_semi_ap)
            dbg_ghost_semi_ap = aim_semi_ap;

        int dbg_num_lights = 0;
        int dbg_light_types[MAX_LIGHTS];
        float dbg_light_pos[MAX_LIGHTS_3];
        float dbg_light_dir[MAX_LIGHTS_3];
        float dbg_light_intensity[MAX_LIGHTS];
        float dbg_light_radius[MAX_LIGHTS];
        load_scene_lights(dbg_num_lights, dbg_light_types, dbg_light_pos,
                          dbg_light_dir, dbg_light_intensity, dbg_light_radius);

        float dbg_r = float(dbg_num_lights) / float(MAX_LIGHTS);

        // Try ABCD inversion for each light to count valid ones
        float dbg_g = 0.0;
        if (dbg_num_lights > 0 && dbg_ghost_semi_ap > 0.0) {
            float dbg_inv_sa = 1.0 / (sensor_z - aim_z);
            float dbg_denom_x = dbg_g_Cx - dbg_g_Dx * dbg_inv_sa;
            float dbg_denom_y = dbg_g_Cy - dbg_g_Dy * dbg_inv_sa;

            if (abs(dbg_denom_x) > 1e-12 && abs(dbg_denom_y) > 1e-12) {
                for (int li = 0; li < dbg_num_lights; li++) {
                    float theta_x = 0.0, theta_y = 0.0;
                    if (dbg_light_types[li] == 1) {
                        float ldz = dbg_light_dir[li * 3 + 2];
                        if (ldz >= 0.0) continue;
                        theta_x = -dbg_light_dir[li * 3 + 0] / ldz;
                        theta_y = -dbg_light_dir[li * 3 + 1] / ldz;
                    } else {
                        float lpz = dbg_light_pos[li * 3 + 2];
                        if (lpz >= vertex_z[0]) continue;
                        float dz_inv = 1.0 / (vertex_z[0] - lpz);
                        theta_x = dbg_light_pos[li * 3 + 0] * dz_inv;
                        theta_y = dbg_light_pos[li * 3 + 1] * dz_inv;
                    }
                    float hx = (-theta_x - dbg_g_Dx * sensor_x * dbg_inv_sa) / dbg_denom_x;
                    float hy = (-theta_y - dbg_g_Dy * sensor_y * dbg_inv_sa) / dbg_denom_y;
                    if (sqrt(hx * hx + hy * hy) <= dbg_ghost_semi_ap * 1.5) {
                        dbg_g = 1.0;
                        break;
                    }
                }
            }
        }

        float dbg_b = 1.0;
        throughput = color(dbg_r, dbg_g, dbg_b);
        return;
    }

    if (trace_ghost) {
        // ABCD ghost pupil: trace paraxial matrices through the full ghost
        // path to find the tightest aperture constraint at the aim plane.
        // Also returns the C,D matrix elements for ABCD inversion (light aiming).
        // Circular sampling (not elliptical) allows anamorphic cylindrical
        // reflections to form vertical streaks.
        float g_Cx = 0.0, g_Dx = 0.0, g_Cy = 0.0, g_Dy = 0.0;
        float ghost_semi_ap = compute_ghost_aim_radius(
            ghost_a, ghost_b, num_surfaces,
            radii, dispersed_iors, apertures, surface_types, vertex_z,
            aperture_scale, sensor_z, aim_z, aim_semi_ap,
            g_Cx, g_Dx, g_Cy, g_Dy);
        ghost_semi_ap *= 1.1;
        if (ghost_semi_ap > aim_semi_ap)
            ghost_semi_ap = aim_semi_ap;

        // Load scene lights for light-aimed ghost sampling
        int num_lights = 0;
        int light_types[MAX_LIGHTS];
        float light_pos[MAX_LIGHTS_3];
        float light_dir[MAX_LIGHTS_3];
        float light_intensity[MAX_LIGHTS];
        float light_radius[MAX_LIGHTS];
        load_scene_lights(num_lights, light_types, light_pos, light_dir,
                          light_intensity, light_radius);

        // 70/30 split: aim at lights vs uniform fallback
        float light_hash = sin(rnd[0] * 73.517 + rnd[1] * 119.203) * 31247.7;
        light_hash = light_hash - floor(light_hash);
        int use_light_aim = 0;
        float pdf_factor = 1.0;
        float aim_x = 0.0, aim_y = 0.0;

        float inv_sa = 1.0 / (sensor_z - aim_z);
        float front_z = vertex_z[0];

        if (num_lights > 0 && ghost_semi_ap > 0.0 && light_hash < 0.7) {
            // ABCD inversion: map desired exit angle to aim-plane position
            float denom_x = g_Cx - g_Dx * inv_sa;
            float denom_y = g_Cy - g_Dy * inv_sa;

            if (abs(denom_x) > 1e-12 && abs(denom_y) > 1e-12) {
                // Compute per-light aim points and weights
                float aim_weights[MAX_LIGHTS];
                float aim_hx[MAX_LIGHTS];
                float aim_hy[MAX_LIGHTS];
                float aim_total = 0.0;

                for (int li = 0; li < num_lights; li++) {
                    aim_weights[li] = 0.0;
                    float theta_x = 0.0, theta_y = 0.0;

                    if (light_types[li] == 1) {
                        // Sun: direction-based
                        float ldz = light_dir[li * 3 + 2];
                        if (ldz >= 0.0) continue;
                        theta_x = -light_dir[li * 3 + 0] / ldz;
                        theta_y = -light_dir[li * 3 + 1] / ldz;
                    } else {
                        // Positional light
                        float lpz = light_pos[li * 3 + 2];
                        if (lpz >= front_z) continue;
                        float dz_inv = 1.0 / (front_z - lpz);
                        theta_x = light_pos[li * 3 + 0] * dz_inv;
                        theta_y = light_pos[li * 3 + 1] * dz_inv;
                    }

                    // Ghost rays exit toward -z, so u_exit = -theta
                    float hx = (-theta_x - g_Dx * sensor_x * inv_sa) / denom_x;
                    float hy = (-theta_y - g_Dy * sensor_y * inv_sa) / denom_y;

                    // Reject if aim point falls outside ghost aperture (1.5x margin
                    // for paraxial approximation error)
                    if (sqrt(hx * hx + hy * hy) > ghost_semi_ap * 1.5)
                        continue;

                    aim_hx[li] = hx;
                    aim_hy[li] = hy;
                    aim_weights[li] = light_intensity[li];
                    aim_total += light_intensity[li];
                }

                if (aim_total > 0.0) {
                    // CDF scan to select light proportional to intensity
                    float sel_hash = sin(rnd[0] * 89.311 + rnd[1] * 47.629) * 42197.3;
                    sel_hash = sel_hash - floor(sel_hash);
                    float target = sel_hash * aim_total;
                    float cumul = 0.0;
                    int sel = -1;

                    for (int li = 0; li < num_lights && sel < 0; li++) {
                        if (aim_weights[li] <= 0.0) continue;
                        cumul += aim_weights[li];
                        if (cumul >= target)
                            sel = li;
                    }

                    if (sel >= 0) {
                        aim_x = aim_hx[sel];
                        aim_y = aim_hy[sel];

                        // Jitter for light angular size
                        if (light_radius[sel] > 0.0) {
                            float radius_angle = 0.0;
                            if (light_types[sel] == 1) {
                                radius_angle = light_radius[sel];
                            } else {
                                float lpz = light_pos[sel * 3 + 2];
                                float d = front_z - lpz;
                                if (d > 1.0)
                                    radius_angle = light_radius[sel] / d;
                            }
                            float jitter_r_x = radius_angle / abs(denom_x);
                            float jitter_r_y = radius_angle / abs(denom_y);
                            float jh = sin(rnd[0] * 53.811 + rnd[1] * 71.439) * 27613.9;
                            jh = jh - floor(jh);
                            float ja = rnd[1] * 2.0 * M_PI;
                            float jr = sqrt(jh);
                            aim_x += jr * cos(ja) * jitter_r_x;
                            aim_y += jr * sin(ja) * jitter_r_y;
                        }

                        // Clamp to ghost aperture
                        float aim_r = sqrt(aim_x * aim_x + aim_y * aim_y);
                        if (aim_r > ghost_semi_ap) {
                            float scale = ghost_semi_ap / aim_r;
                            aim_x *= scale;
                            aim_y *= scale;
                        }

                        use_light_aim = 1;
                        pdf_factor = 1.0 / 0.7;
                    }
                }
            }
        }

        if (!use_light_aim) {
            // Uniform fallback
            float ghost_r = sqrt(r_param) * ghost_semi_ap;
            float ghost_angle = rnd[0] * 2.0 * M_PI;
            aim_x = ghost_r * cos(ghost_angle);
            aim_y = ghost_r * sin(ghost_angle);
            // Only compensate for the 30% allocation when this sample was
            // actually drawn from the uniform pool (light_hash >= 0.7).
            // Failed light-aiming attempts that fall back here use pdf_factor=1.
            if (num_lights > 0 && light_hash >= 0.7)
                pdf_factor = 1.0 / 0.3;
        }

        point ghost_aperture = point(aim_x, aim_y, aim_z);
        vector ghost_initial_dir = normalize(ghost_aperture - sensor_point);

        point ghost_exit = point(0, 0, 0);
        vector ghost_dir = vector(0, 0, 0);
        float ghost_T = 0.0;

        int ghost_ok = trace_ghost_path(
            ghost_a, ghost_b, sensor_point, ghost_initial_dir,
            aperture_scale, num_surfaces,
            radii, iors, apertures, abbe_v, surface_types, extra, vertex_z,
            lambda, aperture_blades, blade_rot_rad, coating,
            ghost_exit, ghost_dir, ghost_T);

        if (ghost_ok) {
            vector axis = vector(0, 0, -1);
            float cos_theta = dot(normalize(ghost_initial_dir), axis);
            float weight = cos_theta * cos_theta * cos_theta * cos_theta;

            int ghosts_only = (debug_mode >= 3.5 && debug_mode < 4.5) ? 1 : 0;
            float frac = ghosts_only ? 1.0 : adaptive_frac;
            float w = weight * (ghost_T / onaxis_T)
                    * (ghost_total_weight / ghost_pair_weight) / frac * ghost_intensity
                    * pdf_factor;

            position = point(ghost_exit[0] * 0.001,
                             ghost_exit[1] * 0.001,
                             -ghost_exit[2] * 0.001);
            direction = normalize(vector(ghost_dir[0], ghost_dir[1], -ghost_dir[2]));

            if (chromatic_aberration) {
                color spectral_norm = color(1.7050, 2.5996, 2.7576);
                color rgb_w = wavelength_to_rgb(lambda) * spectral_norm;
                throughput = color(w * rgb_w[0], w * rgb_w[1], w * rgb_w[2]);
            } else {
                throughput = color(w, w, w);
            }
        } else {
            throughput = 0.0;
        }
        return;
    }

    // Direct path: trace through the lens system
    point  exit_origin = point(0, 0, 0);
    vector exit_dir = vector(0, 0, 0);
    int surfaces_passed = 0;
    int failure_type = 0;
    float total_transmission = 0.0;

    int ok = trace_lens_system(sensor_point, initial_dir, aperture_scale,
                               num_surfaces,
                               radii, thicknesses, iors, apertures,
                               abbe_v, surface_types, extra, lambda,
                               aperture_blades, blade_rot_rad, coating,
                               exit_origin, exit_dir, surfaces_passed, failure_type,
                               total_transmission);

    // Debug mode 2: failure cause diagnostic.
    // White = all passed.
    // Green = aperture clip, Blue = TIR, Red = intersection miss.
    // Brightness = how far the ray got.
    if (debug_mode >= 1.5 && debug_mode < 2.5) {
        position = point(0, 0, 0);
        direction = normalize(vector(-sensor_x, -sensor_y, 50.0));
        if (ok) {
            throughput = color(1, 1, 1);
        } else {
            float brightness = float(surfaces_passed) / float(num_surfaces);
            float is_clip = (failure_type == 2) ? brightness : 0.0;
            float is_tir = (failure_type == 3) ? brightness : 0.0;
            float is_miss = (failure_type == 1) ? brightness : 0.0;
            throughput = color(is_miss, is_clip, is_tir);
        }
        return;
    }

    // Debug mode 3: exit direction as RGB (only for rays that survive)
    if (debug_mode >= 2.5 && debug_mode < 3.5) {
        if (ok) {
            vector d_norm = normalize(exit_dir);
            position = point(0, 0, 0);
            direction = normalize(vector(-sensor_x, -sensor_y, 50.0));
            throughput = color(d_norm[0] * 0.5 + 0.5,
                               d_norm[1] * 0.5 + 0.5,
                               d_norm[2] * 0.5 + 0.5);
        } else {
            throughput = 0.0;
        }
        return;
    }

    if (ok) {
        vector axis = vector(0, 0, -1);
        float cos_theta = dot(normalize(initial_dir), axis);
        float weight = cos_theta * cos_theta * cos_theta * cos_theta;

        float w = weight * (total_transmission / onaxis_T);

        // Compensate for fewer direct samples when ghosts are active
        if (lens_ghosts && num_ghost_pairs > 0)
            w /= (1.0 - adaptive_frac);

        // Aperture diffraction: perturb exit direction to produce starbursts
        if (diffraction) {
            float diff_h1 = sin(rnd[0] * 67.301 + rnd[1] * 131.729) * 39571.7;
            diff_h1 = diff_h1 - floor(diff_h1);
            float diff_h2 = sin(rnd[0] * 113.519 + rnd[1] * 29.853) * 51439.3;
            diff_h2 = diff_h2 - floor(diff_h2);
            float diff_h3 = sin(rnd[0] * 37.719 + rnd[1] * 83.461) * 63197.9;
            diff_h3 = diff_h3 - floor(diff_h3);

            vector diff_perturb = vector(0, 0, 0);
            float diff_w = apply_diffraction(
                aperture_blades, blade_rot_rad, lambda,
                stop_semi_ap * 2.0, diff_h1, diff_h2, diff_h3, diff_perturb);
            w *= diff_w;
            exit_dir = normalize(exit_dir + diff_perturb);
        }

        position = point(exit_origin[0] * 0.001,
                         exit_origin[1] * 0.001,
                         -exit_origin[2] * 0.001);
        direction = normalize(vector(exit_dir[0], exit_dir[1], -exit_dir[2]));

        if (chromatic_aberration) {
            color spectral_norm = color(1.7050, 2.5996, 2.7576);
            color rgb_w = wavelength_to_rgb(lambda) * spectral_norm;
            throughput = color(w * rgb_w[0], w * rgb_w[1], w * rgb_w[2]);
        } else {
            throughput = color(w, w, w);
        }
    } else {
        throughput = 0.0;
    }
}
