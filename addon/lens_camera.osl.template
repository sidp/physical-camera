// {{LENS_DATA}}

// Cauchy dispersion: n(λ) = A + B/λ², coefficients derived from n_d and Abbe number.
float cauchy_ior(float n_d, float v_d, float lambda_nm)
{
    if (v_d < 1.0 || n_d <= 1.0)
        return n_d;

    float inv_lF2 = 1.0 / (486.1 * 486.1);
    float inv_lC2 = 1.0 / (656.3 * 656.3);
    float inv_ld2 = 1.0 / (587.6 * 587.6);
    float B = (n_d - 1.0) / (v_d * (inv_lF2 - inv_lC2));
    float A = n_d - B * inv_ld2;
    return A + B / (lambda_nm * lambda_nm);
}

color wavelength_to_rgb(float lambda)
{
    // Wyman et al. 2013 piecewise Gaussian fits to CIE 1931 XYZ
    float t1 = (lambda - 442.0) * ((lambda < 442.0) ? 0.0624 : 0.0374);
    float t2 = (lambda - 599.8) * ((lambda < 599.8) ? 0.0264 : 0.0323);
    float t3 = (lambda - 501.1) * ((lambda < 501.1) ? 0.0490 : 0.0382);
    float x = 0.362 * exp(-0.5*t1*t1) + 1.056 * exp(-0.5*t2*t2) - 0.065 * exp(-0.5*t3*t3);

    float t4 = (lambda - 568.8) * ((lambda < 568.8) ? 0.0213 : 0.0247);
    float t5 = (lambda - 530.9) * ((lambda < 530.9) ? 0.0613 : 0.0322);
    float y = 0.821 * exp(-0.5*t4*t4) + 0.286 * exp(-0.5*t5*t5);

    float t6 = (lambda - 437.0) * ((lambda < 437.0) ? 0.0845 : 0.0278);
    float t7 = (lambda - 459.0) * ((lambda < 459.0) ? 0.0385 : 0.0725);
    float z = 1.217 * exp(-0.5*t6*t6) + 0.681 * exp(-0.5*t7*t7);

    // XYZ -> linear sRGB (D65)
    float r =  3.2406 * x - 1.5372 * y - 0.4986 * z;
    float g = -0.9689 * x + 1.8758 * y + 0.0415 * z;
    float b =  0.0557 * x - 0.2040 * y + 1.0570 * z;

    return color(max(r, 0.0), max(g, 0.0), max(b, 0.0));
}

float coating_reduction(float n1, float n2, float coating)
{
    if (coating < 0.5 || min(n1, n2) >= 1.01)
        return 0.0;
    float nc = 1.38;
    float lo = min(n1, n2);
    float hi = max(n1, n2);
    float r1 = (lo - nc) / (lo + nc);
    float r2 = (nc - hi) / (nc + hi);
    float denom = 1.0 - r1 * r2;
    float R_coated = (r1 - r2) * (r1 - r2) / (denom * denom);
    float R_bare = (lo - hi) * (lo - hi) / ((lo + hi) * (lo + hi));
    float reduction = (R_bare > 1e-10) ? 1.0 - R_coated / R_bare : 0.0;
    if (coating > 1.5)
        reduction = max(reduction, 0.99);
    return reduction;
}

float fresnel_transmittance(float n1, float n2, float cos_i, float cos_t, float coating)
{
    if (n1 == n2)
        return 1.0;
    float rs = (n1 * cos_i - n2 * cos_t) / (n1 * cos_i + n2 * cos_t);
    float rp = (n1 * cos_t - n2 * cos_i) / (n1 * cos_t + n2 * cos_i);
    float R = (rs * rs + rp * rp) * 0.5;
    R *= (1.0 - coating_reduction(n1, n2, coating));
    return 1.0 - R;
}

int point_in_ngon(float x, float y, float semi_ap, int num_blades, float rotation_rad)
{
    float r = sqrt(x * x + y * y);
    if (r < 1e-10)
        return 1;
    float sector_angle = 2.0 * M_PI / float(num_blades);
    float angle = atan2(y, x) - rotation_rad;
    angle = angle - floor(angle / (2.0 * M_PI)) * 2.0 * M_PI;
    float theta = mod(angle, sector_angle) - sector_angle * 0.5;
    float max_r = semi_ap * cos(M_PI / float(num_blades)) / cos(theta);
    return (r <= max_r) ? 1 : 0;
}

// Project ray to a z-plane and check circular or n-gon aperture.
// Returns 1 if the ray passes, 0 if projection fails, -1 if clipped.
// Sets out_p to the projected point on success.
int check_aperture_at_plane(
    point p, vector d,
    float plane_z, float semi_aperture,
    int surface_type, int num_blades, float blade_rotation,
    output point out_p)
{
    if (abs(d[2]) <= 1e-10)
        return 0;

    float t = (plane_z - p[2]) / d[2];
    float hx = p[0] + t * d[0];
    float hy = p[1] + t * d[1];

    if (surface_type == SURFACE_STOP && num_blades >= 3) {
        if (!point_in_ngon(hx, hy, semi_aperture, num_blades, blade_rotation))
            return -1;
    } else {
        float r = sqrt(hx * hx + hy * hy);
        if (r > semi_aperture)
            return -1;
    }

    out_p = point(hx, hy, plane_z);
    return 1;
}

// Snell's law at a flat surface with Fresnel transmittance.
// Returns 1 on success, 0 on TIR.
int refract_at_flat_plane(
    vector d_in, float n1, float n2, float coating,
    output vector d_out, output float transmission)
{
    if (n1 == n2) {
        d_out = d_in;
        transmission = 1.0;
        return 1;
    }

    vector N = vector(0, 0, -1);
    vector I = normalize(d_in);
    if (dot(I, N) > 0.0)
        N = -N;
    float cos_i = abs(dot(I, N));
    vector refracted = refract(I, N, n1 / n2);
    if (dot(refracted, refracted) < 1e-10)
        return 0;
    float cos_t = abs(dot(refracted, N));
    transmission = fresnel_transmittance(n1, n2, cos_i, cos_t, coating);
    d_out = refracted;
    return 1;
}

float onaxis_fresnel_transmission(
    int num_surfaces,
    float radii[MAX_SURFACES],
    float iors[MAX_SURFACES],
    float coating)
{
    float T = 1.0;
    for (int idx = num_surfaces - 1; idx >= 0; idx--) {
        float n1 = iors[idx];
        float n2 = (idx > 0) ? iors[idx - 1] : 1.0;
        if (n1 == n2)
            continue;
        float R = (n1 - n2) * (n1 - n2) / ((n1 + n2) * (n1 + n2));
        R *= (1.0 - coating_reduction(n1, n2, coating));
        T *= 1.0 - R;
    }
    return T;
}

int is_curved_surface(int surface_type) {
    return (surface_type == SURFACE_SPHERICAL || surface_type == SURFACE_ASPHERIC);
}

float compute_sensor_distance(
    int num_surfaces,
    float radii[MAX_SURFACES],
    float thicknesses[MAX_SURFACES],
    float iors[MAX_SURFACES],
    int surface_types[MAX_SURFACES],
    float total_length,
    float focus_mm)
{
    // Build ABCD system matrix by front-to-back paraxial ray trace.
    // Convention: M = [[A,B],[C,D]], initialized to identity.
    float A = 1.0, B = 0.0, C = 0.0, D = 1.0;

    for (int i = 0; i < num_surfaces; i++) {
        float n_before = (i == 0) ? 1.0 : iors[i - 1];
        float n_after = iors[i];

        // Refraction matrix (curved surfaces have optical power)
        if (is_curved_surface(surface_types[i]) && n_before != n_after) {
            float phi = (n_after - n_before) / radii[i];
            C -= phi * A;
            D -= phi * B;
        }

        // Transfer matrix (skip after last surface)
        if (i < num_surfaces - 1) {
            float t = thicknesses[i] / iors[i];
            A += t * C;
            B += t * D;
        }
    }

    // Fall back to infinity focus if the system has no optical power
    if (abs(C) < 1e-10)
        return -A / C;

    float f = -1.0 / C;
    float bfd = -A / C;
    float rpp = (1.0 - A) / C;
    float fpp = (D - 1.0) / C;

    if (focus_mm <= 0.0)
        return bfd;

    float d_o = focus_mm - total_length + fpp;
    if (d_o <= f)
        return bfd;

    float d_i = f * d_o / (d_o - f);
    return rpp + d_i;
}

void compute_exit_pupil(
    int num_surfaces,
    float radii[MAX_SURFACES],
    float thicknesses[MAX_SURFACES],
    float iors[MAX_SURFACES],
    int surface_types[MAX_SURFACES],
    output float ep_z,
    output float ep_magnification)
{
    int stop_index = 0;
    for (int i = 0; i < num_surfaces; i++) {
        if (surface_types[i] == SURFACE_STOP) { stop_index = i; break; }
    }

    // Build ABCD matrix for the rear subsystem (stop -> rear vertex).
    // This gives the exit pupil position and magnification relative to the
    // physical aperture stop, so we can aim rays at the apparent opening.
    float A = 1.0, B = 0.0, C = 0.0, D = 1.0;

    // Initial transfer from stop to first rear surface
    float t = thicknesses[stop_index] / iors[stop_index];
    A += t * C;
    B += t * D;

    for (int i = stop_index + 1; i < num_surfaces; i++) {
        float n_before = iors[i - 1];
        float n_after = iors[i];

        // Refraction (curved surfaces have optical power)
        if (is_curved_surface(surface_types[i]) && n_before != n_after) {
            float phi = (n_after - n_before) / radii[i];
            C -= phi * A;
            D -= phi * B;
        }

        // Transfer (skip after last surface)
        if (i < num_surfaces - 1) {
            t = thicknesses[i] / iors[i];
            A += t * C;
            B += t * D;
        }
    }

    if (abs(D) < 1e-10) {
        ep_z = 0.0;
        ep_magnification = 0.0;
        return;
    }

    ep_z = -B / D;
    ep_magnification = abs(1.0 / D);
}

void compute_field_exit_pupil(
    float sensor_x, float sensor_y, float sensor_z,
    float ep_z, float stop_z, float aim_semi_ap,
    int num_surfaces,
    int surface_types[MAX_SURFACES],
    float thicknesses[MAX_SURFACES],
    float apertures[MAX_SURFACES],
    output float ep_cx, output float ep_cy, output float ep_r)
{
    int stop_index = 0;
    for (int i = 0; i < num_surfaces; i++) {
        if (surface_types[i] == SURFACE_STOP) { stop_index = i; break; }
    }

    // Chief ray crossing: where a ray from the sensor through the stop center
    // hits the exit pupil plane
    float chief_t = (ep_z - sensor_z) / (stop_z - sensor_z);
    ep_cx = sensor_x * (1.0 - chief_t);
    ep_cy = sensor_y * (1.0 - chief_t);
    ep_r = aim_semi_ap;

    // Accumulate z from stop to each rear surface
    float vz = stop_z;
    for (int i = stop_index + 1; i < num_surfaces; i++) {
        vz += thicknesses[i - 1];
        float semi_ap = apertures[i] * 0.5;

        float t_i = (vz - sensor_z) / (ep_z - sensor_z);
        if (abs(t_i) < 1e-10)
            continue;

        // Constraint circle: projection of surface i's aperture onto the EP plane
        float inv_t = 1.0 / t_i;
        float cc_x = -sensor_x * (1.0 - t_i) * inv_t;
        float cc_y = -sensor_y * (1.0 - t_i) * inv_t;
        float cc_r = semi_ap * abs(inv_t);

        // Largest disk centered at (ep_cx, ep_cy) fitting inside this constraint
        float dx = ep_cx - cc_x;
        float dy = ep_cy - cc_y;
        float dist = sqrt(dx * dx + dy * dy);
        float max_r = cc_r - dist;

        if (max_r < ep_r)
            ep_r = max_r;
    }

    // Safety margin: straight-line projection doesn't account for refraction
    ep_r *= 1.1;
    if (ep_r > aim_semi_ap)
        ep_r = aim_semi_ap;
    if (ep_r < 0.0)
        ep_r = 0.0;
}

int intersect_sphere(
    point ray_origin,
    vector ray_dir,
    float sphere_center_z,
    float radius,
    output point hit_point)
{
    float ox = ray_origin[0];
    float oy = ray_origin[1];
    float oz = ray_origin[2] - sphere_center_z;
    float dx = ray_dir[0];
    float dy = ray_dir[1];
    float dz = ray_dir[2];

    float a = dx * dx + dy * dy + dz * dz;
    float b = 2.0 * (ox * dx + oy * dy + oz * dz);
    float c = ox * ox + oy * oy + oz * oz - radius * radius;

    float disc = b * b - 4.0 * a * c;
    if (disc < 0.0)
        return 0;

    float sqrt_disc = sqrt(disc);
    float t1 = (-b - sqrt_disc) / (2.0 * a);
    float t2 = (-b + sqrt_disc) / (2.0 * a);

    // Pick the intersection closest to the vertex (sphere_center_z - radius).
    // Do NOT fall back to the far-side intersection — if the vertex-side hit
    // is behind the ray, the ray has passed this surface and should be rejected.
    float vertex_z = sphere_center_z - radius;
    point p1 = ray_origin + t1 * ray_dir;
    point p2 = ray_origin + t2 * ray_dir;

    float dist1 = abs(p1[2] - vertex_z);
    float dist2 = abs(p2[2] - vertex_z);

    if (dist1 < dist2) {
        if (t1 > 1e-6) {
            hit_point = p1;
            return 1;
        }
    } else {
        if (t2 > 1e-6) {
            hit_point = p2;
            return 1;
        }
    }

    return 0;
}

float aspheric_sag(float h, float c, float k, float A4, float A6, float A8) {
    float h2 = h * h;
    float Q = max(1.0 - (1.0 + k) * c * c * h2, 1e-20);
    float sag = c * h2 / (1.0 + sqrt(Q)) + A4 * h2 * h2 + A6 * h2 * h2 * h2 + A8 * h2 * h2 * h2 * h2;
    return sag;
}

float aspheric_sag_prime(float h, float c, float k, float A4, float A6, float A8) {
    float h2 = h * h;
    float Q = max(1.0 - (1.0 + k) * c * c * h2, 1e-20);
    return c * h / sqrt(Q) + 4.0 * A4 * h * h2 + 6.0 * A6 * h * h2 * h2 + 8.0 * A8 * h * h2 * h2 * h2;
}

int intersect_aspheric(
    point ray_origin, vector ray_dir,
    float vertex_z, float radius,
    float k, float A4, float A6, float A8,
    output point hit_point)
{
    // Seed with spherical intersection
    point sphere_hit = point(0, 0, 0);
    float sphere_center_z = vertex_z + radius;
    if (!intersect_sphere(ray_origin, ray_dir, sphere_center_z, radius, sphere_hit))
        return 0;

    float c = 1.0 / radius;
    float ox = ray_origin[0], oy = ray_origin[1], oz = ray_origin[2];
    float dx = ray_dir[0], dy = ray_dir[1], dz = ray_dir[2];

    // Initial t from sphere seed
    float t = (abs(dx) > abs(dy))
        ? (sphere_hit[0] - ox) / dx
        : (abs(dy) > 1e-10 ? (sphere_hit[1] - oy) / dy : (sphere_hit[2] - oz) / dz);

    // Newton-Raphson refinement
    float F = 0.0;
    for (int iter = 0; iter < 10; iter++) {
        float px = ox + t * dx;
        float py = oy + t * dy;
        float pz = oz + t * dz;
        float h = sqrt(px * px + py * py);
        float s = aspheric_sag(h, c, k, A4, A6, A8);
        F = pz - vertex_z - s;
        if (abs(F) < 1e-8)
            break;
        float sp = aspheric_sag_prime(h, c, k, A4, A6, A8);
        float dh_dt = (h > 1e-10) ? (px * dx + py * dy) / h : 0.0;
        float dF_dt = dz - sp * dh_dt;
        if (abs(dF_dt) < 1e-20)
            break;
        t -= F / dF_dt;
    }

    if (t < 1e-6 || abs(F) > 1e-4)
        return 0;

    hit_point = point(ox + t * dx, oy + t * dy, oz + t * dz);
    return 1;
}

// Returns: 1 = success, 0 = intersection miss, -1 = aperture clip, -2 = TIR
int refract_at_surface(
    point ray_origin,
    vector ray_dir,
    float vertex_z,
    float radius,
    float semi_aperture,
    float n1,
    float n2,
    int num_blades,
    float blade_rotation,
    int surface_type,
    float coating,
    float k, float A4, float A6, float A8,
    output point new_origin,
    output vector new_dir,
    output float transmission)
{
    if (!is_curved_surface(surface_type)) {
        float dz = ray_dir[2];
        if (abs(dz) < 1e-10)
            return 0;
        float t = (vertex_z - ray_origin[2]) / dz;
        if (t < 1e-6)
            return 0;
        new_origin = ray_origin + t * ray_dir;

        if (surface_type == SURFACE_STOP) {
            // Aperture stop: shaped clipping, no refraction
            if (num_blades >= 3) {
                if (!point_in_ngon(new_origin[0], new_origin[1], semi_aperture, num_blades, blade_rotation))
                    return -1;
            } else {
                float r = sqrt(new_origin[0] * new_origin[0] + new_origin[1] * new_origin[1]);
                if (r > semi_aperture)
                    return -1;
            }
            new_dir = ray_dir;
            transmission = 1.0;
            return 1;
        }

        // Flat refractive surface: circular clip + Snell's law
        float r = sqrt(new_origin[0] * new_origin[0] + new_origin[1] * new_origin[1]);
        if (r > semi_aperture)
            return -1;

        if (n1 == n2) {
            new_dir = ray_dir;
            transmission = 1.0;
            return 1;
        }

        vector N = vector(0, 0, -1);
        vector I = normalize(ray_dir);
        if (dot(I, N) > 0.0)
            N = -N;
        float cos_i = abs(dot(I, N));
        vector refracted = refract(I, N, n1 / n2);
        if (dot(refracted, refracted) < 1e-10)
            return -2;
        float cos_t = abs(dot(refracted, N));
        transmission = fresnel_transmittance(n1, n2, cos_i, cos_t, coating);
        new_dir = refracted;
        return 1;
    }

    point hit = point(0, 0, 0);

    if (surface_type == SURFACE_ASPHERIC) {
        if (!intersect_aspheric(ray_origin, ray_dir, vertex_z, radius, k, A4, A6, A8, hit))
            return 0;
    } else {
        float sphere_center_z = vertex_z + radius;
        if (!intersect_sphere(ray_origin, ray_dir, sphere_center_z, radius, hit))
            return 0;
    }

    // Aperture clip
    float r = sqrt(hit[0] * hit[0] + hit[1] * hit[1]);
    if (r > semi_aperture)
        return -1;

    // Surface normal
    vector N;
    if (surface_type == SURFACE_ASPHERIC) {
        float c = 1.0 / radius;
        float h = sqrt(hit[0] * hit[0] + hit[1] * hit[1]);
        if (h > 1e-10) {
            float sp = aspheric_sag_prime(h, c, k, A4, A6, A8);
            N = normalize(vector(-sp * hit[0] / h, -sp * hit[1] / h, 1.0));
        } else {
            N = vector(0, 0, 1);
        }
    } else {
        float sphere_center_z = vertex_z + radius;
        N = normalize(hit - point(0, 0, sphere_center_z));
    }

    // Flip normal to face the incoming ray
    vector I = normalize(ray_dir);
    if (dot(I, N) > 0.0)
        N = -N;

    float cos_i = abs(dot(I, N));
    float eta = n1 / n2;
    vector refracted = refract(I, N, eta);

    // TIR check: refract() returns zero vector on total internal reflection
    if (dot(refracted, refracted) < 1e-10)
        return -2;

    float cos_t = abs(dot(refracted, N));
    transmission = (n1 == n2) ? 1.0 : fresnel_transmittance(n1, n2, cos_i, cos_t, coating);

    new_origin = hit;
    new_dir = refracted;
    return 1;
}

// failure_type output: 0 = success, 1 = intersection miss, 2 = aperture clip, 3 = TIR
int trace_lens_system(
    point ray_origin,
    vector ray_dir,
    float aperture_scale,
    int num_surfaces,
    float radii[MAX_SURFACES],
    float thicknesses[MAX_SURFACES],
    float iors[MAX_SURFACES],
    float apertures[MAX_SURFACES],
    float abbe_v[MAX_SURFACES],
    int surface_types[MAX_SURFACES],
    float extra[MAX_EXTRA],
    float lambda_nm,
    int num_blades,
    float blade_rotation,
    float coating,
    output point exit_origin,
    output vector exit_dir,
    output int surfaces_passed,
    output int failure_type,
    output float total_transmission)
{
    surfaces_passed = 0;
    failure_type = 0;
    total_transmission = 1.0;

    // Compute vertex z-positions (PBRT convention: front at most negative z,
    // rear at z=0). This ensures sphere curvature pushes off-axis hits away
    // from subsequent surfaces, preventing overshoot at thin air gaps.
    float vertex_z[MAX_SURFACES];
    float total_length = 0.0;
    for (int i = 0; i < num_surfaces - 1; i++)
        total_length += thicknesses[i];

    vertex_z[0] = -total_length;
    for (int i = 1; i < num_surfaces; i++)
        vertex_z[i] = vertex_z[i - 1] + thicknesses[i - 1];

    point  p = ray_origin;
    vector d = ray_dir;

    // State saved before flat surfaces for sphere-overlap retry.
    // When a curved surface's sphere extends past an adjacent flat surface,
    // we may need to roll back and reprocess. Two cases:
    //   Overshoot: curved hit overshoots past the next flat — handle flat early
    //   Mirror: flat processed first but curved sphere is unreachable — retry
    point saved_p = point(0, 0, 0);
    vector saved_d = vector(0, 0, 0);
    float saved_transmission = 0.0;
    int saved_surfaces = 0;
    int saved_idx = -1;

    // Trace rear-to-front: last surface down to surface 0
    int skip_count = 0;
    for (int idx = num_surfaces - 1; idx >= 0; idx--) {
        if (skip_count > 0) {
            skip_count -= 1;
            saved_idx = -1;
            continue;
        }

        // Save ray state before flat surfaces for sphere-overlap retry
        if (!is_curved_surface(surface_types[idx])) {
            saved_p = p;
            saved_d = d;
            saved_transmission = total_transmission;
            saved_surfaces = surfaces_passed;
            saved_idx = idx;
        }

        float semi_ap = apertures[idx] * 0.5;

        if (surface_types[idx] == SURFACE_STOP)
            semi_ap *= aperture_scale;

        // iors[i] = IOR of the medium between surface i and surface i+1
        // (toward sensor). When tracing sensor→scene at surface idx:
        // n1 = medium the ray is in (sensor side) = iors[idx]
        // n2 = medium the ray enters (scene side) = iors[idx-1] or air
        float n1 = cauchy_ior(iors[idx], abbe_v[idx], lambda_nm);
        float n2 = (idx > 0) ? cauchy_ior(iors[idx - 1], abbe_v[idx - 1], lambda_nm) : 1.0;

        if (surface_types[idx] == SURFACE_STOP) {
            n1 = 1.0;
            n2 = 1.0;
        }

        int base = idx * N_EXTRA;
        float k_i = extra[base], A4_i = extra[base + 1], A6_i = extra[base + 2], A8_i = extra[base + 3];

        point  new_p = point(0, 0, 0);
        vector new_d = vector(0, 0, 0);
        float surface_transmission = 1.0;

        int result = refract_at_surface(p, d, vertex_z[idx], radii[idx], semi_ap, n1, n2, num_blades, blade_rotation, surface_types[idx], coating, k_i, A4_i, A6_i, A8_i, new_p, new_d, surface_transmission);

        // Mirror case: a flat surface was processed but the adjacent curved
        // surface's sphere extends past it, making intersection unreachable.
        // Roll back to before the flat surface and retry the curved one first.
        if (result != 1 && is_curved_surface(surface_types[idx]) && saved_idx == idx + 1) {
            p = saved_p;
            d = saved_d;
            total_transmission = saved_transmission;
            surfaces_passed = saved_surfaces;
            saved_idx = -1;

            result = refract_at_surface(p, d, vertex_z[idx], radii[idx], semi_ap, n1, n2, num_blades, blade_rotation, surface_types[idx], coating, k_i, A4_i, A6_i, A8_i, new_p, new_d, surface_transmission);
            if (result != 1) {
                if (result == 0) failure_type = 1;
                else if (result == -1) failure_type = 2;
                else if (result == -2) failure_type = 3;
                return 0;
            }

            surfaces_passed += 1;
            total_transmission *= surface_transmission;
            p = new_p;
            d = new_d;

            // Now handle the flat surface we rolled back
            int flat_idx = idx + 1;
            float flat_semi_ap = apertures[flat_idx] * 0.5;
            if (surface_types[flat_idx] == SURFACE_STOP)
                flat_semi_ap *= aperture_scale;

            point flat_p;
            int flat_check = check_aperture_at_plane(p, d, vertex_z[flat_idx], flat_semi_ap,
                                                     surface_types[flat_idx], num_blades, blade_rotation, flat_p);
            if (flat_check != 1) {
                failure_type = (flat_check == 0) ? 1 : 2;
                return 0;
            }
            p = flat_p;

            if (surface_types[flat_idx] != SURFACE_STOP) {
                float fn1 = cauchy_ior(iors[flat_idx], abbe_v[flat_idx], lambda_nm);
                float fn2 = (flat_idx > 0) ? cauchy_ior(iors[flat_idx - 1], abbe_v[flat_idx - 1], lambda_nm) : 1.0;
                vector flat_d; float flat_trans;
                if (!refract_at_flat_plane(d, fn1, fn2, coating, flat_d, flat_trans)) {
                    failure_type = 3;
                    return 0;
                }
                total_transmission *= flat_trans;
                d = flat_d;
            }

            surfaces_passed += 1;
            continue;
        }

        if (result != 1) {
            if (result == 0) failure_type = 1;
            else if (result == -1) failure_type = 2;
            else if (result == -2) failure_type = 3;
            return 0;
        }

        surfaces_passed += 1;
        total_transmission *= surface_transmission;
        p = new_p;
        d = new_d;

        if (is_curved_surface(surface_types[idx]))
            saved_idx = -1;

        // Overshoot: a curved surface hit overshoots past the next flat
        // surface's vertex. Handle the flat surface now and skip it later.
        if (idx > 0 && !is_curved_surface(surface_types[idx - 1]) && p[2] < vertex_z[idx - 1]) {
            int next_idx = idx - 1;
            float next_semi_ap = apertures[next_idx] * 0.5;
            if (surface_types[next_idx] == SURFACE_STOP)
                next_semi_ap *= aperture_scale;

            point next_p;
            int next_check = check_aperture_at_plane(p, d, vertex_z[next_idx], next_semi_ap,
                                                     surface_types[next_idx], num_blades, blade_rotation, next_p);
            if (next_check != 1) {
                failure_type = (next_check == 0) ? 1 : 2;
                return 0;
            }
            p = next_p;

            if (surface_types[next_idx] != SURFACE_STOP) {
                float fn1 = cauchy_ior(iors[next_idx], abbe_v[next_idx], lambda_nm);
                float fn2 = (next_idx > 0) ? cauchy_ior(iors[next_idx - 1], abbe_v[next_idx - 1], lambda_nm) : 1.0;
                vector next_d; float next_trans;
                if (!refract_at_flat_plane(d, fn1, fn2, coating, next_d, next_trans)) {
                    failure_type = 3;
                    return 0;
                }
                total_transmission *= next_trans;
                d = next_d;
            }

            surfaces_passed += 1;
            skip_count = 1;
        }
    }

    exit_origin = p;
    exit_dir = d;
    return 1;
}

shader lens_camera(
    float aperture_scale = 1.0
        [[ string description = "Scale factor for the aperture stop opening. 1.0 = wide open." ]],
    int lens_type = 0
        [[ string description = "Lens selection index (see add-on UI for available lenses)." ]],
    int aperture_blades = 0
        [[ string description = "Number of aperture blades. 0 = circular." ]],
    float blade_rotation = 0.0
        [[ string description = "Aperture blade rotation in degrees." ]],
    int chromatic_aberration = 1
        [[ string description = "Enable chromatic aberration (spectral dispersion)." ]],
    float debug_mode = 0.0
        [[ string description = "0=normal, 1=pinhole, 2=surface count, 3=exit direction" ]],
    output point position = 0,
    output vector direction = 0,
    output color throughput = 1)
{
    // Sensor size from Blender camera
    vector sensor_size = 0;
    getattribute("cam:sensor_size", sensor_size);
    float sensor_w = sensor_size[0];
    float sensor_h = sensor_size[1];

    float focal_distance = 0.0;
    getattribute("cam:focal_distance", focal_distance);

    // Raster position (0-1 range)
    point raster = camera_shader_raster_position();
    float rx = raster[0];
    float ry = raster[1];

    // Map raster coordinates to physical sensor position (mm).
    // Negate to compensate for lens inversion (real lenses flip the image).
    float sensor_x = (0.5 - rx) * sensor_w;
    float sensor_y = (0.5 - ry) * sensor_h;

    // Debug mode 1: pinhole camera to verify the framework
    // +Z is the view direction in Blender's OSL camera convention
    if (debug_mode >= 0.5 && debug_mode < 1.5) {
        position = point(0, 0, 0);
        direction = normalize(vector(-sensor_x, -sensor_y, 50.0));
        throughput = 1.0;
        return;
    }

    // Load lens data
    float radii[MAX_SURFACES];
    float thicknesses[MAX_SURFACES];
    float iors[MAX_SURFACES];
    float apertures[MAX_SURFACES];
    float abbe_v[MAX_SURFACES];
    int surface_types[MAX_SURFACES];
    float extra[MAX_EXTRA];
    float thicknesses_close[MAX_SURFACES];
    float focus_close_distance = 0.0;
    int num_surfaces = 0;
    float coating = 0.0;
    load_lens_data(lens_type, radii, thicknesses, iors, apertures, abbe_v,
                   surface_types, extra, thicknesses_close, focus_close_distance,
                   num_surfaces, coating);

    int stop_index = 0;
    for (int i = 0; i < num_surfaces; i++) {
        if (surface_types[i] == SURFACE_STOP) { stop_index = i; break; }
    }

    float focus_mm = focal_distance * 1000.0;

    // Interpolate variable thicknesses for current focus distance.
    // Uses linear interpolation in reciprocal object-distance space.
    if (focus_close_distance > 0.0 && focus_mm > 0.0) {
        float total_length_inf = 0.0;
        for (int i = 0; i < num_surfaces - 1; i++)
            total_length_inf += thicknesses[i];

        float d_obj = focus_mm - total_length_inf;
        float alpha = (d_obj > 0.0)
            ? clamp(focus_close_distance / d_obj, 0.0, 1.0)
            : 1.0;

        for (int i = 0; i < num_surfaces; i++)
            thicknesses[i] = mix(thicknesses[i], thicknesses_close[i], alpha);
    }

    float total_length = 0.0;
    for (int i = 0; i < num_surfaces - 1; i++)
        total_length += thicknesses[i];
    float sensor_distance = compute_sensor_distance(
        num_surfaces, radii, thicknesses, iors, surface_types, total_length, focus_mm);

    // camera_shader_random_sample() provides two uniform values in x/y.
    // x = aperture angle (sector + barycentric u1), y = barycentric u2; the
    // actual aperture radius is derived from both barycentric coordinates.
    // Wavelength is derived from a hash of both to avoid correlation with
    // aperture position — a linear mapping would preserve the quasi-random
    // sequence structure and create systematic color-position patterns.
    point rnd = camera_shader_random_sample();

    // Wavelength sampling for chromatic aberration
    float lambda = 587.6;
    float r_param = rnd[1];
    if (chromatic_aberration) {
        float h = sin(rnd[0] * 12.9898 + rnd[1] * 78.233) * 43758.5453;
        lambda = 400.0 + (h - floor(h)) * 300.0;
    }

    // Compute wavelength-adjusted IOR for exit pupil aiming and Fresnel
    // normalization. Lenses with high dispersion shift the exit pupil at
    // extreme wavelengths; d-line-only aiming causes intersection misses.
    float dispersed_iors[MAX_SURFACES];
    for (int i = 0; i < num_surfaces; i++)
        dispersed_iors[i] = cauchy_ior(iors[i], abbe_v[i], lambda);

    float onaxis_T = onaxis_fresnel_transmission(num_surfaces, radii, dispersed_iors, coating);

    // Lens layout: rear element at z=0, front element at z=-total_length.
    // Sensor is behind the rear element at z = +sensor_distance.
    float sensor_z = sensor_distance;
    point sensor_point = point(sensor_x, sensor_y, sensor_z);

    // Compute the aperture stop's z-position
    float stop_z = -total_length;
    for (int i = 0; i < stop_index; i++)
        stop_z += thicknesses[i];

    // Sample on the exit pupil plane to reduce wasted rays for off-axis points.
    // The exit pupil is the image of the aperture stop as seen through the rear
    // lens group — it differs in position and size from the physical stop.
    float stop_semi_ap = apertures[stop_index] * 0.5 * aperture_scale;

    float ep_z = 0.0;
    float ep_magnification = 1.0;
    compute_exit_pupil(num_surfaces, radii, thicknesses, dispersed_iors, surface_types,
                       ep_z, ep_magnification);
    float aim_z = (ep_magnification > 0.0) ? ep_z : stop_z;
    float aim_semi_ap = (ep_magnification > 0.0) ? stop_semi_ap * ep_magnification : stop_semi_ap;

    float ep_cx = 0.0, ep_cy = 0.0, field_semi_ap = aim_semi_ap;
    compute_field_exit_pupil(sensor_x, sensor_y, sensor_z,
                             aim_z, stop_z, aim_semi_ap,
                             num_surfaces, surface_types,
                             thicknesses, apertures,
                             ep_cx, ep_cy, field_semi_ap);

    if (field_semi_ap <= 0.0) {
        throughput = 0.0;
        return;
    }

    float blade_rot_rad = blade_rotation * M_PI / 180.0;
    float ax = 0.0;
    float ay = 0.0;

    // Ngon barycentric sampling: rnd[0] selects the sector and u1,
    // rnd[1] provides u2. Wavelength is hashed separately so it has
    // no systematic relationship to aperture position.
    // For circular aperture (blades=0), use 128-gon as a proxy.
    {
        int n = (aperture_blades >= 3) ? aperture_blades : 128;
        float sector_angle = 2.0 * M_PI / float(n);
        int sector = int(floor(rnd[0] * float(n)));
        if (sector >= n) sector = n - 1;
        float u1 = rnd[0] * float(n) - float(sector);
        float u2 = r_param;
        if (u1 + u2 > 1.0) {
            u1 = 1.0 - u1;
            u2 = 1.0 - u2;
        }
        float a0 = blade_rot_rad + float(sector) * sector_angle;
        float a1 = blade_rot_rad + float(sector + 1) * sector_angle;
        ax = u1 * field_semi_ap * cos(a0) + u2 * field_semi_ap * cos(a1);
        ay = u1 * field_semi_ap * sin(a0) + u2 * field_semi_ap * sin(a1);
    }

    ax += ep_cx;
    ay += ep_cy;

    point aperture_point = point(ax, ay, aim_z);

    // Initial ray: sensor toward the stop
    vector initial_dir = normalize(aperture_point - sensor_point);

    // Trace through the lens system
    point  exit_origin = point(0, 0, 0);
    vector exit_dir = vector(0, 0, 0);
    int surfaces_passed = 0;
    int failure_type = 0;
    float total_transmission = 0.0;

    int ok = trace_lens_system(sensor_point, initial_dir, aperture_scale,
                               num_surfaces,
                               radii, thicknesses, iors, apertures,
                               abbe_v, surface_types, extra, lambda,
                               aperture_blades, blade_rot_rad, coating,
                               exit_origin, exit_dir, surfaces_passed, failure_type,
                               total_transmission);

    // Debug mode 2: failure cause diagnostic.
    // White = all passed.
    // Green = aperture clip, Blue = TIR, Red = intersection miss.
    // Brightness = how far the ray got.
    if (debug_mode >= 1.5 && debug_mode < 2.5) {
        position = point(0, 0, 0);
        direction = normalize(vector(-sensor_x, -sensor_y, 50.0));
        if (ok) {
            throughput = color(1, 1, 1);
        } else {
            float brightness = float(surfaces_passed) / float(num_surfaces);
            float is_clip = (failure_type == 2) ? brightness : 0.0;
            float is_tir = (failure_type == 3) ? brightness : 0.0;
            float is_miss = (failure_type == 1) ? brightness : 0.0;
            throughput = color(is_miss, is_clip, is_tir);
        }
        return;
    }

    // Debug mode 3: exit direction as RGB (only for rays that survive)
    if (debug_mode >= 2.5 && debug_mode < 3.5) {
        if (ok) {
            vector d_norm = normalize(exit_dir);
            position = point(0, 0, 0);
            direction = normalize(vector(-sensor_x, -sensor_y, 50.0));
            throughput = color(d_norm[0] * 0.5 + 0.5,
                               d_norm[1] * 0.5 + 0.5,
                               d_norm[2] * 0.5 + 0.5);
        } else {
            throughput = 0.0;
        }
        return;
    }

    // Normal mode: output in camera space (Blender applies camera transform).
    // Lens space has -z toward scene; Blender camera space has +z toward scene.
    // Negate z to convert.
    if (ok) {
        // Throughput weight: cos^4(theta) models natural radiometric falloff.
        vector axis = vector(0, 0, -1);
        float cos_theta = dot(normalize(initial_dir), axis);
        float weight = cos_theta * cos_theta * cos_theta * cos_theta;

        float w = weight * (total_transmission / onaxis_T);

        position = point(exit_origin[0] * 0.001,
                         exit_origin[1] * 0.001,
                         -exit_origin[2] * 0.001);
        direction = normalize(vector(exit_dir[0], exit_dir[1], -exit_dir[2]));

        if (chromatic_aberration) {
            color spectral_norm = color(1.7050, 2.5996, 2.7576);
            color rgb_w = wavelength_to_rgb(lambda) * spectral_norm;
            throughput = color(w * rgb_w[0], w * rgb_w[1], w * rgb_w[2]);
        } else {
            throughput = color(w, w, w);
        }
    } else {
        throughput = 0.0;
    }
}
