// {{LENS_DATA}}

// Cauchy dispersion: n(λ) = A + B/λ², coefficients derived from n_d and Abbe number.
float cauchy_ior(float n_d, float v_d, float lambda_nm)
{
    if (v_d < 1.0 || n_d <= 1.0)
        return n_d;

    float inv_lF2 = 1.0 / (486.1 * 486.1);
    float inv_lC2 = 1.0 / (656.3 * 656.3);
    float inv_ld2 = 1.0 / (587.6 * 587.6);
    float B = (n_d - 1.0) / (v_d * (inv_lF2 - inv_lC2));
    float A = n_d - B * inv_ld2;
    return A + B / (lambda_nm * lambda_nm);
}

color wavelength_to_rgb(float lambda)
{
    // Wyman et al. 2013 piecewise Gaussian fits to CIE 1931 XYZ
    float t1 = (lambda - 442.0) * ((lambda < 442.0) ? 0.0624 : 0.0374);
    float t2 = (lambda - 599.8) * ((lambda < 599.8) ? 0.0264 : 0.0323);
    float t3 = (lambda - 501.1) * ((lambda < 501.1) ? 0.0490 : 0.0382);
    float x = 0.362 * exp(-0.5*t1*t1) + 1.056 * exp(-0.5*t2*t2) - 0.065 * exp(-0.5*t3*t3);

    float t4 = (lambda - 568.8) * ((lambda < 568.8) ? 0.0213 : 0.0247);
    float t5 = (lambda - 530.9) * ((lambda < 530.9) ? 0.0613 : 0.0322);
    float y = 0.821 * exp(-0.5*t4*t4) + 0.286 * exp(-0.5*t5*t5);

    float t6 = (lambda - 437.0) * ((lambda < 437.0) ? 0.0845 : 0.0278);
    float t7 = (lambda - 459.0) * ((lambda < 459.0) ? 0.0385 : 0.0725);
    float z = 1.217 * exp(-0.5*t6*t6) + 0.681 * exp(-0.5*t7*t7);

    // XYZ -> linear sRGB (D65)
    float r =  3.2406 * x - 1.5372 * y - 0.4986 * z;
    float g = -0.9689 * x + 1.8758 * y + 0.0415 * z;
    float b =  0.0557 * x - 0.2040 * y + 1.0570 * z;

    return color(max(r, 0.0), max(g, 0.0), max(b, 0.0));
}

float fresnel_transmittance(float n1, float n2, float cos_i, float cos_t)
{
    if (n1 == n2)
        return 1.0;
    float rs = (n1 * cos_i - n2 * cos_t) / (n1 * cos_i + n2 * cos_t);
    float rp = (n1 * cos_t - n2 * cos_i) / (n1 * cos_t + n2 * cos_i);
    return 1.0 - (rs * rs + rp * rp) * 0.5;
}

float onaxis_fresnel_transmission(
    int num_surfaces,
    float radii[MAX_SURFACES],
    float iors[MAX_SURFACES])
{
    float T = 1.0;
    for (int idx = num_surfaces - 1; idx >= 0; idx--) {
        float n1 = iors[idx];
        float n2 = (idx > 0) ? iors[idx - 1] : 1.0;
        if (n1 == n2)
            continue;
        float r = (n1 - n2) / (n1 + n2);
        T *= 1.0 - r * r;
    }
    return T;
}

float compute_sensor_distance(
    int num_surfaces,
    float radii[MAX_SURFACES],
    float thicknesses[MAX_SURFACES],
    float iors[MAX_SURFACES],
    float total_length,
    float focus_mm)
{
    // Build ABCD system matrix by front-to-back paraxial ray trace.
    // Convention: M = [[A,B],[C,D]], initialized to identity.
    float A = 1.0, B = 0.0, C = 0.0, D = 1.0;

    for (int i = 0; i < num_surfaces; i++) {
        float n_before = (i == 0) ? 1.0 : iors[i - 1];
        float n_after = iors[i];

        // Refraction matrix (skip flat surfaces and matching IOR)
        if (radii[i] != 0.0 && n_before != n_after) {
            float phi = (n_after - n_before) / radii[i];
            C -= phi * A;
            D -= phi * B;
        }

        // Transfer matrix (skip after last surface)
        if (i < num_surfaces - 1) {
            float t = thicknesses[i] / iors[i];
            A += t * C;
            B += t * D;
        }
    }

    // Fall back to infinity focus if the system has no optical power
    if (abs(C) < 1e-10)
        return -A / C;

    float f = -1.0 / C;
    float bfd = -A / C;
    float rpp = (1.0 - A) / C;
    float fpp = (D - 1.0) / C;

    if (focus_mm <= 0.0)
        return bfd;

    float d_o = focus_mm - total_length + fpp;
    if (d_o <= f)
        return bfd;

    float d_i = f * d_o / (d_o - f);
    return rpp + d_i;
}

void compute_exit_pupil(
    int num_surfaces,
    int stop_index,
    float radii[MAX_SURFACES],
    float thicknesses[MAX_SURFACES],
    float iors[MAX_SURFACES],
    output float ep_z,
    output float ep_magnification)
{
    // Build ABCD matrix for the rear subsystem (stop -> rear vertex).
    // This gives the exit pupil position and magnification relative to the
    // physical aperture stop, so we can aim rays at the apparent opening.
    float A = 1.0, B = 0.0, C = 0.0, D = 1.0;

    // Initial transfer from stop to first rear surface
    float t = thicknesses[stop_index] / iors[stop_index];
    A += t * C;
    B += t * D;

    for (int i = stop_index + 1; i < num_surfaces; i++) {
        float n_before = iors[i - 1];
        float n_after = iors[i];

        // Refraction
        if (radii[i] != 0.0 && n_before != n_after) {
            float phi = (n_after - n_before) / radii[i];
            C -= phi * A;
            D -= phi * B;
        }

        // Transfer (skip after last surface)
        if (i < num_surfaces - 1) {
            t = thicknesses[i] / iors[i];
            A += t * C;
            B += t * D;
        }
    }

    if (abs(D) < 1e-10) {
        ep_z = 0.0;
        ep_magnification = 0.0;
        return;
    }

    ep_z = -B / D;
    ep_magnification = abs(1.0 / D);
}

void compute_field_exit_pupil(
    float sensor_x, float sensor_y, float sensor_z,
    float ep_z, float stop_z, float aim_semi_ap,
    int num_surfaces, int stop_index,
    float thicknesses[MAX_SURFACES],
    float apertures[MAX_SURFACES],
    output float ep_cx, output float ep_cy, output float ep_r)
{
    // Chief ray crossing: where a ray from the sensor through the stop center
    // hits the exit pupil plane
    float chief_t = (ep_z - sensor_z) / (stop_z - sensor_z);
    ep_cx = sensor_x * (1.0 - chief_t);
    ep_cy = sensor_y * (1.0 - chief_t);
    ep_r = aim_semi_ap;

    // Accumulate z from stop to each rear surface
    float vz = stop_z;
    for (int i = stop_index + 1; i < num_surfaces; i++) {
        vz += thicknesses[i - 1];
        float semi_ap = apertures[i] * 0.5;

        float t_i = (vz - sensor_z) / (ep_z - sensor_z);
        if (abs(t_i) < 1e-10)
            continue;

        // Constraint circle: projection of surface i's aperture onto the EP plane
        float inv_t = 1.0 / t_i;
        float cc_x = -sensor_x * (1.0 - t_i) * inv_t;
        float cc_y = -sensor_y * (1.0 - t_i) * inv_t;
        float cc_r = semi_ap * abs(inv_t);

        // Largest disk centered at (ep_cx, ep_cy) fitting inside this constraint
        float dx = ep_cx - cc_x;
        float dy = ep_cy - cc_y;
        float dist = sqrt(dx * dx + dy * dy);
        float max_r = cc_r - dist;

        if (max_r < ep_r)
            ep_r = max_r;
    }

    // Safety margin: straight-line projection doesn't account for refraction
    ep_r *= 1.1;
    if (ep_r > aim_semi_ap)
        ep_r = aim_semi_ap;
    if (ep_r < 0.0)
        ep_r = 0.0;
}

int point_in_ngon(float x, float y, float semi_ap, int num_blades, float rotation_rad)
{
    float r = sqrt(x * x + y * y);
    if (r < 1e-10)
        return 1;
    float sector_angle = 2.0 * M_PI / float(num_blades);
    float angle = atan2(y, x) - rotation_rad;
    angle = angle - floor(angle / (2.0 * M_PI)) * 2.0 * M_PI;
    float theta = mod(angle, sector_angle) - sector_angle * 0.5;
    float max_r = semi_ap * cos(M_PI / float(num_blades)) / cos(theta);
    return (r <= max_r) ? 1 : 0;
}

int intersect_sphere(
    point ray_origin,
    vector ray_dir,
    float sphere_center_z,
    float radius,
    output point hit_point)
{
    float ox = ray_origin[0];
    float oy = ray_origin[1];
    float oz = ray_origin[2] - sphere_center_z;
    float dx = ray_dir[0];
    float dy = ray_dir[1];
    float dz = ray_dir[2];

    float a = dx * dx + dy * dy + dz * dz;
    float b = 2.0 * (ox * dx + oy * dy + oz * dz);
    float c = ox * ox + oy * oy + oz * oz - radius * radius;

    float disc = b * b - 4.0 * a * c;
    if (disc < 0.0)
        return 0;

    float sqrt_disc = sqrt(disc);
    float t1 = (-b - sqrt_disc) / (2.0 * a);
    float t2 = (-b + sqrt_disc) / (2.0 * a);

    // Pick the intersection closest to the vertex (sphere_center_z - radius).
    // Do NOT fall back to the far-side intersection — if the vertex-side hit
    // is behind the ray, the ray has passed this surface and should be rejected.
    float vertex_z = sphere_center_z - radius;
    point p1 = ray_origin + t1 * ray_dir;
    point p2 = ray_origin + t2 * ray_dir;

    float dist1 = abs(p1[2] - vertex_z);
    float dist2 = abs(p2[2] - vertex_z);

    if (dist1 < dist2) {
        if (t1 > 1e-6) {
            hit_point = p1;
            return 1;
        }
    } else {
        if (t2 > 1e-6) {
            hit_point = p2;
            return 1;
        }
    }

    return 0;
}

// Returns: 1 = success, 0 = intersection miss, -1 = aperture clip, -2 = TIR
int refract_at_surface(
    point ray_origin,
    vector ray_dir,
    float vertex_z,
    float radius,
    float semi_aperture,
    float n1,
    float n2,
    int num_blades,
    float blade_rotation,
    int is_stop,
    output point new_origin,
    output vector new_dir,
    output float transmission)
{
    if (radius == 0.0) {
        float dz = ray_dir[2];
        if (abs(dz) < 1e-10)
            return 0;
        float t = (vertex_z - ray_origin[2]) / dz;
        if (t < 1e-6)
            return 0;
        new_origin = ray_origin + t * ray_dir;

        if (is_stop) {
            // Aperture stop: shaped clipping, no refraction
            if (num_blades >= 3) {
                if (!point_in_ngon(new_origin[0], new_origin[1], semi_aperture, num_blades, blade_rotation))
                    return -1;
            } else {
                float r = sqrt(new_origin[0] * new_origin[0] + new_origin[1] * new_origin[1]);
                if (r > semi_aperture)
                    return -1;
            }
            new_dir = ray_dir;
            transmission = 1.0;
            return 1;
        }

        // Flat refractive surface: circular clip + Snell's law
        float r = sqrt(new_origin[0] * new_origin[0] + new_origin[1] * new_origin[1]);
        if (r > semi_aperture)
            return -1;

        if (n1 == n2) {
            new_dir = ray_dir;
            transmission = 1.0;
            return 1;
        }

        vector N = vector(0, 0, -1);
        vector I = normalize(ray_dir);
        if (dot(I, N) > 0.0)
            N = -N;
        float cos_i = abs(dot(I, N));
        vector refracted = refract(I, N, n1 / n2);
        if (dot(refracted, refracted) < 1e-10)
            return -2;
        float cos_t = abs(dot(refracted, N));
        transmission = fresnel_transmittance(n1, n2, cos_i, cos_t);
        new_dir = refracted;
        return 1;
    }

    float sphere_center_z = vertex_z + radius;
    point hit = point(0, 0, 0);

    if (!intersect_sphere(ray_origin, ray_dir, sphere_center_z, radius, hit))
        return 0;

    // Aperture clip
    float r = sqrt(hit[0] * hit[0] + hit[1] * hit[1]);
    if (r > semi_aperture)
        return -1;

    // Surface normal: points from sphere center to hit point
    vector N = normalize(hit - point(0, 0, sphere_center_z));

    // Flip normal to face the incoming ray
    vector I = normalize(ray_dir);
    if (dot(I, N) > 0.0)
        N = -N;

    float cos_i = abs(dot(I, N));
    float eta = n1 / n2;
    vector refracted = refract(I, N, eta);

    // TIR check: refract() returns zero vector on total internal reflection
    if (dot(refracted, refracted) < 1e-10)
        return -2;

    float cos_t = abs(dot(refracted, N));
    transmission = (n1 == n2) ? 1.0 : fresnel_transmittance(n1, n2, cos_i, cos_t);

    new_origin = hit;
    new_dir = refracted;
    return 1;
}

// failure_type output: 0 = success, 1 = intersection miss, 2 = aperture clip, 3 = TIR
int trace_lens_system(
    point ray_origin,
    vector ray_dir,
    float aperture_scale,
    int num_surfaces,
    int stop_index,
    float radii[MAX_SURFACES],
    float thicknesses[MAX_SURFACES],
    float iors[MAX_SURFACES],
    float apertures[MAX_SURFACES],
    float abbe_v[MAX_SURFACES],
    float lambda_nm,
    int num_blades,
    float blade_rotation,
    output point exit_origin,
    output vector exit_dir,
    output int surfaces_passed,
    output int failure_type,
    output float total_transmission)
{
    surfaces_passed = 0;
    failure_type = 0;
    total_transmission = 1.0;

    // Compute vertex z-positions (PBRT convention: front at most negative z,
    // rear at z=0). This ensures sphere curvature pushes off-axis hits away
    // from subsequent surfaces, preventing overshoot at thin air gaps.
    float vertex_z[MAX_SURFACES];
    float total_length = 0.0;
    for (int i = 0; i < num_surfaces - 1; i++)
        total_length += thicknesses[i];

    vertex_z[0] = -total_length;
    for (int i = 1; i < num_surfaces; i++)
        vertex_z[i] = vertex_z[i - 1] + thicknesses[i - 1];

    point  p = ray_origin;
    vector d = ray_dir;

    // State saved before flat surfaces for sphere-overlap retry
    point pre_flat_p = point(0, 0, 0);
    vector pre_flat_d = vector(0, 0, 0);
    float pre_flat_transmission = 0.0;
    int pre_flat_surfaces = 0;
    int pre_flat_idx = -1;

    // Trace rear-to-front: last surface down to surface 0
    int skip_surface = 0;
    for (int idx = num_surfaces - 1; idx >= 0; idx--) {
        if (skip_surface) {
            skip_surface = 0;
            pre_flat_idx = -1;
            continue;
        }

        // Save ray state before flat surfaces for sphere-overlap retry
        if (radii[idx] == 0.0) {
            pre_flat_p = p;
            pre_flat_d = d;
            pre_flat_transmission = total_transmission;
            pre_flat_surfaces = surfaces_passed;
            pre_flat_idx = idx;
        }

        float semi_ap = apertures[idx] * 0.5;

        if (idx == stop_index)
            semi_ap *= aperture_scale;

        // iors[i] = IOR of the medium between surface i and surface i+1
        // (toward sensor). When tracing sensor→scene at surface idx:
        // n1 = medium the ray is in (sensor side) = iors[idx]
        // n2 = medium the ray enters (scene side) = iors[idx-1] or air
        float n1 = cauchy_ior(iors[idx], abbe_v[idx], lambda_nm);
        float n2 = (idx > 0) ? cauchy_ior(iors[idx - 1], abbe_v[idx - 1], lambda_nm) : 1.0;

        // No refraction at aperture stop
        if (idx == stop_index) {
            n1 = 1.0;
            n2 = 1.0;
        }

        int is_stop = (idx == stop_index) ? 1 : 0;

        point  new_p = point(0, 0, 0);
        vector new_d = vector(0, 0, 0);
        float surface_transmission = 1.0;

        int result = refract_at_surface(p, d, vertex_z[idx], radii[idx], semi_ap, n1, n2, num_blades, blade_rotation, is_stop, new_p, new_d, surface_transmission);
        if (result != 1) {
            // Mirror case of the overshoot below: a flat surface was
            // processed first but the next curved surface's sphere
            // extends past it, making the sphere unreachable. Retry
            // from the pre-flat position, then project to the flat
            // surface for the aperture check.
            if (radii[idx] != 0.0 && pre_flat_idx == idx + 1) {
                p = pre_flat_p;
                d = pre_flat_d;
                total_transmission = pre_flat_transmission;
                surfaces_passed = pre_flat_surfaces;
                pre_flat_idx = -1;

                result = refract_at_surface(p, d, vertex_z[idx], radii[idx], semi_ap, n1, n2, num_blades, blade_rotation, is_stop, new_p, new_d, surface_transmission);
                if (result != 1) {
                    if (result == 0) failure_type = 1;
                    else if (result == -1) failure_type = 2;
                    else if (result == -2) failure_type = 3;
                    return 0;
                }

                surfaces_passed += 1;
                total_transmission *= surface_transmission;
                p = new_p;
                d = new_d;

                int flat_idx = idx + 1;
                float flat_z = vertex_z[flat_idx];
                float flat_semi_ap = apertures[flat_idx] * 0.5;
                int flat_is_stop = (flat_idx == stop_index) ? 1 : 0;

                if (flat_is_stop)
                    flat_semi_ap *= aperture_scale;

                if (abs(d[2]) <= 1e-10) {
                    failure_type = 1;
                    return 0;
                }

                float t_proj = (flat_z - p[2]) / d[2];
                float check_x = p[0] + t_proj * d[0];
                float check_y = p[1] + t_proj * d[1];

                if (flat_is_stop && num_blades >= 3) {
                    if (!point_in_ngon(check_x, check_y, flat_semi_ap, num_blades, blade_rotation)) {
                        failure_type = 2;
                        return 0;
                    }
                } else {
                    float r_check = sqrt(check_x * check_x + check_y * check_y);
                    if (r_check > flat_semi_ap) {
                        failure_type = 2;
                        return 0;
                    }
                }

                p = point(check_x, check_y, flat_z);

                if (!flat_is_stop) {
                    float fn1 = cauchy_ior(iors[flat_idx], abbe_v[flat_idx], lambda_nm);
                    float fn2 = (flat_idx > 0) ? cauchy_ior(iors[flat_idx - 1], abbe_v[flat_idx - 1], lambda_nm) : 1.0;
                    if (fn1 != fn2) {
                        vector fN = vector(0, 0, -1);
                        vector fI = normalize(d);
                        if (dot(fI, fN) > 0.0)
                            fN = -fN;
                        float fcos_i = abs(dot(fI, fN));
                        vector refr = refract(fI, fN, fn1 / fn2);
                        if (dot(refr, refr) < 1e-10) {
                            failure_type = 3;
                            return 0;
                        }
                        float fcos_t = abs(dot(refr, fN));
                        total_transmission *= fresnel_transmittance(fn1, fn2, fcos_i, fcos_t);
                        d = refr;
                    }
                }

                surfaces_passed += 1;
                continue;
            }

            if (result == 0) failure_type = 1;
            else if (result == -1) failure_type = 2;
            else if (result == -2) failure_type = 3;
            return 0;
        }

        surfaces_passed += 1;
        total_transmission *= surface_transmission;
        p = new_p;
        d = new_d;

        if (radii[idx] != 0.0)
            pre_flat_idx = -1;

        // A strongly curved surface close to a flat surface can have its
        // sphere extend past the flat surface's vertex. When the hit point
        // overshoots, project the refracted ray back to the flat surface's
        // plane for the aperture check — this gives the correct air-side
        // position where light physically crosses the flat surface.
        if (idx > 0 && radii[idx - 1] == 0.0 && p[2] < vertex_z[idx - 1]) {
            int next_idx = idx - 1;
            float flat_z = vertex_z[next_idx];
            float next_semi_ap = apertures[next_idx] * 0.5;
            int next_is_stop = (next_idx == stop_index) ? 1 : 0;

            if (next_is_stop)
                next_semi_ap *= aperture_scale;

            // Project refracted ray back to the flat surface plane
            if (abs(d[2]) <= 1e-10) {
                failure_type = 1;
                return 0;
            }

            float t_proj = (flat_z - p[2]) / d[2];
            float check_x = p[0] + t_proj * d[0];
            float check_y = p[1] + t_proj * d[1];

            if (next_is_stop && num_blades >= 3) {
                if (!point_in_ngon(check_x, check_y, next_semi_ap, num_blades, blade_rotation)) {
                    failure_type = 2;
                    return 0;
                }
            } else {
                float r_check = sqrt(check_x * check_x + check_y * check_y);
                if (r_check > next_semi_ap) {
                    failure_type = 2;
                    return 0;
                }
            }

            p = point(check_x, check_y, flat_z);

            if (!next_is_stop) {
                float fn1 = cauchy_ior(iors[next_idx], abbe_v[next_idx], lambda_nm);
                float fn2 = (next_idx > 0) ? cauchy_ior(iors[next_idx - 1], abbe_v[next_idx - 1], lambda_nm) : 1.0;
                if (fn1 != fn2) {
                    vector fN = vector(0, 0, -1);
                    vector fI = normalize(d);
                    if (dot(fI, fN) > 0.0)
                        fN = -fN;
                    float fcos_i = abs(dot(fI, fN));
                    vector refr = refract(fI, fN, fn1 / fn2);
                    if (dot(refr, refr) < 1e-10) {
                        failure_type = 3;
                        return 0;
                    }
                    float fcos_t = abs(dot(refr, fN));
                    total_transmission *= fresnel_transmittance(fn1, fn2, fcos_i, fcos_t);
                    d = refr;
                }
            }

            surfaces_passed += 1;
            skip_surface = 1;
        }
    }

    exit_origin = p;
    exit_dir = d;
    return 1;
}

shader lens_camera(
    float aperture_scale = 1.0
        [[ string description = "Scale factor for the aperture stop opening. 1.0 = wide open." ]],
    int lens_type = 0
        [[ string description = "Lens selection index (see add-on UI for available lenses)." ]],
    int aperture_blades = 0
        [[ string description = "Number of aperture blades. 0 = circular." ]],
    float blade_rotation = 0.0
        [[ string description = "Aperture blade rotation in degrees." ]],
    int chromatic_aberration = 1
        [[ string description = "Enable chromatic aberration (spectral dispersion)." ]],
    float debug_mode = 0.0
        [[ string description = "0=normal, 1=pinhole, 2=surface count, 3=exit direction" ]],
    output point position = 0,
    output vector direction = 0,
    output color throughput = 1)
{
    // Sensor size from Blender camera
    vector sensor_size = 0;
    getattribute("cam:sensor_size", sensor_size);
    float sensor_w = sensor_size[0];
    float sensor_h = sensor_size[1];

    float focal_distance = 0.0;
    getattribute("cam:focal_distance", focal_distance);

    // Raster position (0-1 range)
    point raster = camera_shader_raster_position();
    float rx = raster[0];
    float ry = raster[1];

    // Map raster coordinates to physical sensor position (mm).
    // Negate to compensate for lens inversion (real lenses flip the image).
    float sensor_x = (0.5 - rx) * sensor_w;
    float sensor_y = (0.5 - ry) * sensor_h;

    // Debug mode 1: pinhole camera to verify the framework
    // +Z is the view direction in Blender's OSL camera convention
    if (debug_mode >= 0.5 && debug_mode < 1.5) {
        position = point(0, 0, 0);
        direction = normalize(vector(-sensor_x, -sensor_y, 50.0));
        throughput = 1.0;
        return;
    }

    // Load lens data
    float radii[MAX_SURFACES];
    float thicknesses[MAX_SURFACES];
    float iors[MAX_SURFACES];
    float apertures[MAX_SURFACES];
    float abbe_v[MAX_SURFACES];
    int num_surfaces = 0;
    int stop_index = 0;
    load_lens_data(lens_type, radii, thicknesses, iors, apertures, abbe_v,
                   num_surfaces, stop_index);

    float total_length = 0.0;
    for (int i = 0; i < num_surfaces - 1; i++)
        total_length += thicknesses[i];

    float focus_mm = focal_distance * 1000.0;
    float sensor_distance = compute_sensor_distance(
        num_surfaces, radii, thicknesses, iors, total_length, focus_mm);

    // camera_shader_random_sample() provides two independent uniform values in x/y.
    // x = aperture angle, y = wavelength (+ golden-ratio rotation for aperture radius).
    point rnd = camera_shader_random_sample();

    // Wavelength sampling for chromatic aberration
    float lambda = 587.6;
    float r_param = rnd[1];
    if (chromatic_aberration) {
        lambda = 400.0 + rnd[1] * 300.0;
        r_param = rnd[1] + 0.6180339887;
        r_param = r_param - floor(r_param);
    }

    // Compute wavelength-adjusted IOR for exit pupil aiming and Fresnel
    // normalization. Lenses with high dispersion shift the exit pupil at
    // extreme wavelengths; d-line-only aiming causes intersection misses.
    float dispersed_iors[MAX_SURFACES];
    for (int i = 0; i < num_surfaces; i++)
        dispersed_iors[i] = cauchy_ior(iors[i], abbe_v[i], lambda);

    float onaxis_T = onaxis_fresnel_transmission(num_surfaces, radii, dispersed_iors);

    // Lens layout: rear element at z=0, front element at z=-total_length.
    // Sensor is behind the rear element at z = +sensor_distance.
    float sensor_z = sensor_distance;
    point sensor_point = point(sensor_x, sensor_y, sensor_z);

    // Compute the aperture stop's z-position
    float stop_z = -total_length;
    for (int i = 0; i < stop_index; i++)
        stop_z += thicknesses[i];

    // Sample on the exit pupil plane to reduce wasted rays for off-axis points.
    // The exit pupil is the image of the aperture stop as seen through the rear
    // lens group — it differs in position and size from the physical stop.
    float stop_semi_ap = apertures[stop_index] * 0.5 * aperture_scale;

    float ep_z = 0.0;
    float ep_magnification = 1.0;
    compute_exit_pupil(num_surfaces, stop_index, radii, thicknesses, dispersed_iors,
                       ep_z, ep_magnification);
    float aim_z = (ep_magnification > 0.0) ? ep_z : stop_z;
    float aim_semi_ap = (ep_magnification > 0.0) ? stop_semi_ap * ep_magnification : stop_semi_ap;

    float ep_cx = 0.0, ep_cy = 0.0, field_semi_ap = aim_semi_ap;
    compute_field_exit_pupil(sensor_x, sensor_y, sensor_z,
                             aim_z, stop_z, aim_semi_ap,
                             num_surfaces, stop_index,
                             thicknesses, apertures,
                             ep_cx, ep_cy, field_semi_ap);

    if (field_semi_ap <= 0.0) {
        throughput = 0.0;
        return;
    }

    float blade_rot_rad = blade_rotation * M_PI / 180.0;
    float ax = 0.0;
    float ay = 0.0;

    if (aperture_blades >= 3) {
        int n = aperture_blades;
        float sector_angle = 2.0 * M_PI / float(n);
        int sector = int(floor(rnd[0] * float(n)));
        if (sector >= n) sector = n - 1;
        float u1 = rnd[0] * float(n) - float(sector);
        float u2 = r_param;
        if (u1 + u2 > 1.0) {
            u1 = 1.0 - u1;
            u2 = 1.0 - u2;
        }
        float a0 = blade_rot_rad + float(sector) * sector_angle;
        float a1 = blade_rot_rad + float(sector + 1) * sector_angle;
        ax = u1 * field_semi_ap * cos(a0) + u2 * field_semi_ap * cos(a1);
        ay = u1 * field_semi_ap * sin(a0) + u2 * field_semi_ap * sin(a1);
    } else {
        float angle = rnd[0] * 2.0 * M_PI;
        float r_sample = sqrt(r_param) * field_semi_ap;
        ax = r_sample * cos(angle);
        ay = r_sample * sin(angle);
    }

    ax += ep_cx;
    ay += ep_cy;

    point aperture_point = point(ax, ay, aim_z);

    // Initial ray: sensor toward the stop
    vector initial_dir = normalize(aperture_point - sensor_point);

    // Trace through the lens system
    point  exit_origin = point(0, 0, 0);
    vector exit_dir = vector(0, 0, 0);
    int surfaces_passed = 0;
    int failure_type = 0;
    float total_transmission = 0.0;

    int ok = trace_lens_system(sensor_point, initial_dir, aperture_scale,
                               num_surfaces, stop_index,
                               radii, thicknesses, iors, apertures,
                               abbe_v, lambda,
                               aperture_blades, blade_rot_rad,
                               exit_origin, exit_dir, surfaces_passed, failure_type,
                               total_transmission);

    // Debug mode 2: failure cause diagnostic.
    // White = all passed.
    // Green = aperture clip, Blue = TIR, Red = intersection miss.
    // Brightness = how far the ray got.
    if (debug_mode >= 1.5 && debug_mode < 2.5) {
        position = point(0, 0, 0);
        direction = normalize(vector(-sensor_x, -sensor_y, 50.0));
        if (ok) {
            throughput = color(1, 1, 1);
        } else {
            float brightness = float(surfaces_passed) / float(num_surfaces);
            float is_clip = (failure_type == 2) ? brightness : 0.0;
            float is_tir = (failure_type == 3) ? brightness : 0.0;
            float is_miss = (failure_type == 1) ? brightness : 0.0;
            throughput = color(is_miss, is_clip, is_tir);
        }
        return;
    }

    // Debug mode 3: exit direction as RGB (only for rays that survive)
    if (debug_mode >= 2.5 && debug_mode < 3.5) {
        if (ok) {
            vector d_norm = normalize(exit_dir);
            position = point(0, 0, 0);
            direction = normalize(vector(-sensor_x, -sensor_y, 50.0));
            throughput = color(d_norm[0] * 0.5 + 0.5,
                               d_norm[1] * 0.5 + 0.5,
                               d_norm[2] * 0.5 + 0.5);
        } else {
            throughput = 0.0;
        }
        return;
    }

    // Normal mode: output in camera space (Blender applies camera transform).
    // Lens space has -z toward scene; Blender camera space has +z toward scene.
    // Negate z to convert.
    if (ok) {
        // Throughput weight: cos^4(theta) models natural radiometric falloff.
        vector axis = vector(0, 0, -1);
        float cos_theta = dot(normalize(initial_dir), axis);
        float weight = cos_theta * cos_theta * cos_theta * cos_theta;

        float w = weight * (total_transmission / onaxis_T);

        position = point(exit_origin[0] * 0.001,
                         exit_origin[1] * 0.001,
                         -exit_origin[2] * 0.001);
        direction = normalize(vector(exit_dir[0], exit_dir[1], -exit_dir[2]));

        if (chromatic_aberration) {
            color spectral_norm = color(1.7050, 2.5996, 2.7576);
            color rgb_w = wavelength_to_rgb(lambda) * spectral_norm;
            throughput = color(w * rgb_w[0], w * rgb_w[1], w * rgb_w[2]);
        } else {
            throughput = color(w, w, w);
        }
    } else {
        throughput = 0.0;
    }
}
